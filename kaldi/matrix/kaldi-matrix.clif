from "matrix/matrix-common-clifwrap.h" import *
from "matrix/kaldi-vector-clifwrap.h" import *

from "matrix/kaldi-matrix.h":
    namespace `kaldi`:
        class `MatrixBase<float>` as MatrixBase:
            num_rows_: int = property(`NumRows`)
            num_cols_: int = property(`NumCols`)

            # FIXME (VM): maybe?
            # stride_: int = property(`stride_`)

            def Stride(self) -> int

            def SizeInBytes(self) -> int

            # def Data(self) -> float*
            # def RowData(self) -> float*

            # FIXME(Dogan): Argument order is reversed in C++. Handle in Python.
            # @sequential
            # def `CopyRowFromVec` as __setitem__(self, r: int, v: VectorBase)

            # Note (VM):
            # __getitem__ takes only two arguments (self, index), but
            # here we need three (self, row, col).
            # We cannot use a perfect mapping
            def `operator()` as _getitem(self, r:int, c:int) -> float

            def `Set` as _setitem(self, r:int, c:int, v:float)

            def SetZero(self)

            def SetUnit(self)

            def SetRandn(self)

            def SetRandUniform(self)

            # Copying functions #
            def CopyFromMat(self, M:MatrixBase, trans:MatrixTransposeType = default)

            # FIXME (VM): Missing definitions
            # def `CopyFromMat` as CopyFromCudaMat(self, M:CuMatrixBase, trans:MatrixTransposeType = default)
            # def CopyFromMat(self, M:CompressedMatrix);
            # def CopyFromSp(self, M:SpMatrix);
            # def CopyFromTp(self, M:TpMatrix, trans:MatrixTransposeType = default)
            # def `CopyRowsFromVec` as CopyRowFromCudaVec(self, v:CuVector)

            def CopyRowsFromVec(self, v:VectorBase)

            def `CopyColsFromVec` as CopyColsFromVec(self, v:VectorBase)

            def CopyColFromVec(self, v:VectorBase, col:int)

            def CopyRowFromVec(self, v:VectorBase, row:int)

            def CopyDiagFromVec(self, v:VectorBase)

            # Accessing sub-parts of matrix #
            # Note (VM):
            # Implemented in child class Matrix<Real>

            # Special functions #

            def Sum(self) -> float

            def Trace(self, check_square: bool = default) -> float

            def Max(self) -> float

            def Min(self) -> float

            def `MulElements` as __mult__(self, A: MatrixBase)

            def `DivElements` as __div__(self, A: MatrixBase)

            def Scale(self, alpha: float)

            def `Max` as MaxWithMat(self, A: MatrixBase)

            def `Min` as MinWithMat(self, A: MatrixBase)

            def MulColsVec(self, scale: VectorBase)

            def MulRowsVec(self, scale: VectorBase)

            def MulRowsGroupMat(self, src: MatrixBase)

            # FIXME:
            def LogDet(self, det_sign: `float` as float = default) -> float
            def Invert(self, log_det: `float` as float = default, det_sign: `float` as float = default, inverse_needed: bool = default)
            def InvertDouble(self, logDet: `float` as float = default, det_sign: `float` as float = default, inverse_needed: bool = default)

            def InvertElements(self)

            def Transpose(self)

            def CopyCols(self, src: MatrixBase, indices: int)

            def CopyRows(self, src: MatrixBase, indices: int)

            def AddCols(self, src: MatrixBase, indices: int)

            # FIXME:
            # void CopyRows(const Real *const *src);
            # void CopyToRows(Real *const *dst) const;

            def AddRows(self, alpha: float, src: MatrixBase, indexes: int)

            # FIXME:
            # void AddRows(Real alpha, const Real *const *src);
            # void AddToRows(Real alpha, Real *const *dst) const;

            def ApplyFloor(self, floor_val: float)

            def ApplyCeiling(self, ceiling_val: float)

            def ApplyLog(self)

            def ApplyExp(self)

            def ApplyPow(self, power: float)

            def ApplyPowAbs(self, power: float, include_sign: bool = default)

            def ApplyHeaviside(self)

            # FIXME:
            #  This doesn't work because VectorBase<Real>() is protected
            # def Eig(self, P: MatrixBase) -> (eigs_real: VectorBase, eigs_imag: VectorBase)

            def Power(self, pow: float) -> bool

            # FIXME:
            # void Svd(VectorBase<Real> *s, MatrixBase<Real> *U, MatrixBase<Real> *Vt) const;

            def Svd(self, s: VectorBase)

            def MinSingularValue(self) -> float

            def TestUninitialized(self)

            def Cond(self) -> float

            def IsSymmetric(self, cutoff: float = default) -> bool

            def IsDiagonal(self, cutoff: float = default) -> bool

            def IsUnit(self, cutoff: float = default) -> bool

            def IsZero(self, cutoff: float = default) -> bool

            def FrobeniusNorm(self) -> float

            def ApproxEqual(self, other: MatrixBase, tol: float = default) -> bool

            def Equal(self, other: MatrixBase) -> bool

            def LargestAbsElem(self) -> float

            def LogSumExp(self, prune: float = default) -> float

            def ApplySoftMax(self) -> float

            def Sigmoid(self, src: MatrixBase)

            def Heaviside(self, src: MatrixBase)

            def SoftHinge(self, src: MatrixBase)

            def GroupPnorm(self, src: MatrixBase, power: float)

            # FIXME:
            # This doesn't follow Google conventions for C++,
            # where inputs must come before any output
            # def GroupPnormDeriv(self, input: MatrixBase, output: MatrixBase, power: float)

            def GroupMax(self, src: MatrixBase)

            def GroupMaxDeriv(self, input: MatrixBase, output: MatrixBase)

            def Tanh(self, src: MatrixBase)

            def DiffSigmoid(self, value: MatrixBase, diff: MatrixBase)

            def DiffTanh(self, value: MatrixBase, diff: MatrixBase)

            def SymPosSemiDefEig(self, s: VectorBase, P: MatrixBase, check_thresh: float = default)

            # FIXME:
            # What to do here?
            # friend Real kaldi::TraceMatMat<Real>(const MatrixBase<Real> &A,
            # const MatrixBase<Real> &B, MatrixTransposeType trans);  // tr (A B)

            def Add(self, alpha: float)

            def AddToDiag(self, alpha: float)

            def AddVecVec(self, alpha: float, a: VectorBase, b: VectorBase)

            def AddVecToRows(self, alpha: float, v: VectorBase)

            def AddVecToCols(self, alpha: float, v: VectorBase)

            def AddMat(self, alpha: float, M: MatrixBase, transA: MatrixTransposeType = default)

            def SymAddMat2(self, alpha: float, M: MatrixBase, transA: MatrixTransposeType, beta: float)

            def AddDiagVecMat(self, alpha: float, v: VectorBase, M: MatrixBase, transM: MatrixTransposeType, beta: float = default)

            def AddMatDiagVec(self, alpha: float, M: MatrixBase, transM: MatrixTransposeType, v: VectorBase, beta: float = default)

            def AddMatMatElements(self, alpha: float, A: MatrixBase, B: MatrixBase, beta: float)

            # FIXME:
            # Missing SpMatrix definition
            # def AddSp(self, alpha: float, S:SpMatrix)

            def AddMatMat(self, alpha: float, A: MatrixBase, transA: MatrixTransposeType, B: MatrixBase, transB: MatrixTransposeType, beta: float)

            def SetMatMatDivMat(self, A: MatrixBase, B: MatrixBase, C: MatrixBase)

            def AddMatSmat(self, alpha: float, A: MatrixBase, transA: MatrixTransposeType, B: MatrixBase, transB: MatrixTransposeType, beta: float)

            def AddSmatMat(self, alpha: float, A: MatrixBase, transA: MatrixTransposeType, B: MatrixBase, transB: MatrixTransposeType, beta: float)

            def AddMatMatMat(self, alpha: float, A: MatrixBase, transA: MatrixTransposeType, B: MatrixBase, transB: MatrixTransposeType, C: MatrixBase, transC: MatrixTransposeType, beta: float)

            # FIXME:
            # Missing definitions
            # def AddSpMat(self, alpha: float, A:SpMatrix, B: MatrixBase, transB: MatrixTransposeType, beta: float)
            # def AddTpMat(self, alpha: float, A:TpMatrix, transA: MatrixTransposeType, B: MatrixBase, transB: MatrixTransposeType, beta: float)
            # def AddMatSp(self, alpha: float, A: MatrixBase, transA: MatrixTransposeType, B:SpMatrix, beta: float)
            # def AddMatTp(self, alpha: float, A: MatrixBase, transA: MatrixTransposeType, B:TpMatrix, transB: MatrixTransposeType, beta: float)
            # def AddTpTp
            # def AddSpSp

            def CopyLowerToUpper(self)

            def CopyUpperToLower(self)

            def OrthogonalizeRows(self)

            # Note (VM): nothing to do here
            # void Read(std::istream & in, bool binary, bool add = false);
            # void Write(std::ostream & out, bool binary) const;

        # class `SubMatrix<float>` as SubMatrix(MatrixBase):
        #
        #     def __init__(self, T:MatrixBase, ro:int, r:int, co:int, c:int)
        #
        #     # Note:
        #     # We cannot wrap this constructor automatically since CLIF does
        #     # not support wrapping raw data pointers.
        #     # @add__init__
        #     # def `SubMatrix` as NewWithData(self, data:`float` as float, num_rows: int, num_cols: int, stride: int)
        #
        #     @add__init__
        #     def `SubMatrix` as NewWithSubMatrix(self, other:SubMatrix)

        #     # Accessing of sub-parts of the matrix. #
        #     def Row(self, i:int) -> SubVector

        #     def Range(self, row_offset:int, num_rows:int, col_offset:int, num_cols: int) -> SubMatrix

        #     def RowRange(self, row_offset: int, num_rows: int) -> SubMatrix

        #     def ColRange(self, col_offset: int, num_cols: int) -> SubMatrix


        class `Matrix<float>` as Matrix(MatrixBase):

            @add__init__
            def `Matrix` as NewWithSize(self, r:int, c:int, resize_type:MatrixResizeType = default, stride_type:MatrixStrideType = default)

            # TODO:
            # explicit Matrix(const CuMatrixBase<OtherReal> &cu,
                  # MatrixTransposeType trans = kNoTrans);

            def Swap(self, other:Matrix)

            # TODO:
            # void Swap(CuMatrix<Real> *mat);

            @add__init__
            def `Matrix` as NewWithMatrix(self, M:MatrixBase, trans:MatrixTransposeType = default)

            # TODO:
            # @add__init__
            # def `Matrix` as FromSpMatrix(self, M:SpMatrix)
            # @add__init__
            # def `Matrix` as FromCompressedMatrix(self, C:CompressedMatrix)
            # @add__init__
            # def `Matrix` as FromCompressedMatrix(self, M:TpMatrix, trans:MatrixTransposeType = default)

            # Note (VM):
            # Are we implementing this?
            # void Read(std::istream & in, bool binary, bool add = false);

            def RemoveRow(self, i:int)

            def Transpose(self)

            def Resize(self, r:int, c:int,
                       resize_type:MatrixResizeType = default,
                       stride_type:MatrixStrideType = default)

            # Todo (VM):
            # <strikethrough>Check if this actually works</strikethrough>
            # Better to do it in python
            # def `operator=` as __copy__(self, other:MatrixBase) -> Matrix

            # NOTE (VM):
            # This is actually a private method,
            # so it might not be a good idea to wrap it
            # def `Init` as __init__(self, r:int, c:int)

            # NOTE:
            # We cannot wrap Row here since SubVector is wrapped elsewhere.
            # We implement it in Python by constructing a SubVector object.
            # def Row(self, i:int) -> SubVector

            # NOTE:
            # We cannot wrap *Range here since SubMatrix is wrapped elsewhere.
            # We implement them in Python by constructing SubMatrix objects.
            # def Range(self, row_offset:int, num_rows:int, col_offset:int, num_cols: int) -> SubMatrix
            #
            # def RowRange(self, row_offset: int, num_rows: int) -> SubMatrix
            #
            # def ColRange(self, col_offset: int, num_cols: int) -> SubMatrix



        def `TraceMat` as TraceMat(A: MatrixBase) -> float

        def `TraceMatMatMat` as TraceMatMatMat(A: MatrixBase, transA: MatrixTransposeType,
                                               B: MatrixBase, transB: MatrixTransposeType,
                                               C: MatrixBase, transC: MatrixTransposeType) -> float

        def `TraceMatMatMatMat` as TraceMatMatMatMat(A: MatrixBase, transA: MatrixTransposeType,
                                                     B: MatrixBase, transB: MatrixTransposeType,
                                                     C: MatrixBase, transC: MatrixTransposeType,
                                                     D: MatrixBase, transD: MatrixTransposeType) -> float

        def `ApproxEqual` as ApproxEqualMatrix(A:MatrixBase, B:MatrixBase, tol:`float` as float = default) -> bool

        def `AssertEqual` as AssertEqualMatrix(A:MatrixBase, B:MatrixBase, tol:`float` as float = default)

        # Note (VM):
        # Cannot be implemented as it is because outputs are before inputs
        # def `SortSVD` as SortSVD(s: VectorBase, U: MatrixBase, Vt: MatrixBase, sort_on_absolute_value: bool = default)

        def `CreateEigenvalueMatrix` as CreateEigenvalueMatrix(real:VectorBase, imag:VectorBase, D:MatrixBase)

        def `AttemptComplexPower` as AttemptComplexPower(x_re:float, x_im:float, power:float) -> bool

        # TODO (VM):
        # def `operator<<` as Write(out: ostream, M: MatrixBase) -> ostream
        # def `operator>>` as Write(in: istream, M: MatrixBase) -> istream
        # def `operator>>` as Write(in: istream, M: Matrix) -> istream

        def `SameDim` as SameDimMatrix(M: MatrixBase, N: MatrixBase) -> bool


        class HtkHeader:
            mNSamples: int
            mSamplePeriod: int
            mSampleSize: int
            mSampleKind: int

        # TODO:
        # template<typename Real>
        # bool ReadHtk(std::istream &is, Matrix<Real> *M, HtkHeader *header_ptr);

        # // Write (HTK format) features to file from matrix.
        # template<typename Real>
        # bool WriteHtk(std::ostream &os, const MatrixBase<Real> &M, HtkHeader htk_hdr);

        # // Write (CMUSphinx format) features to file from matrix.
        # template<typename Real>
        # bool WriteSphinx(std::ostream &os, const MatrixBase<Real> &M);
