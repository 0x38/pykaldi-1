from "base/iostream-clifwrap.h" import *
from "itf/options-itf-clifwrap.h" import *
from "fstext/lattice-weight-clifwrap.h" import *
from "fstext/vector-fst-clifwrap.h" import *
from "hmm/transition-model-clifwrap.h" import *

from "lat/word-align-lattice.h":
  namespace `kaldi`:
    class WordBoundaryInfoNewOpts:
      """Options for word alignment using word boundary phones."""
      silence_label: int
      """Label for silence arcs."""
      partial_word_label: int
      """Label for partial word arcs at the end of "forced-out" utterances."""
      reorder: bool
      """Whether lattice was created from a graph with reorder option set."""

      def `Register` as register(self, opts: OptionsItf):
        """Registers options with an object implementing the options interface.

        Args:
          opts (OptionsItf): An object implementing the options interface.
            Typically a command-line option parser.
        """

    class WordBoundaryInfo:
      """WordBoundaryInfo(opts)

      Word boundary information.

      Args:
        opts (WordBoundaryInfoNewOpts): Decoder options.
      """
      def __init__(self, opts: WordBoundaryInfoNewOpts)

      @add__init__
      def `WordBoundaryInfo` as from_file(
        self, opts: WordBoundaryInfoNewOpts, word_boundary_file: str):
        """Creates a new `WordBoundaryInfo` object from file."""

      def `Init` as init(self, is: istream):
        """Initializes with information read from an input stream."""

      enum PhoneType with:
        `kNoPhone` as NO_PHONE
        `kWordBeginPhone` as WORD_BEGIN_PHONE
        `kWordEndPhone` as WORD_END_PHONE
        `kWordBeginAndEndPhone` as WORD_BEGIN_AND_END_PHONE
        `kWordInternalPhone` as WORD_INTERNAL_PHONE
        `kNonWordPhone` as NON_WORD_PHONE

      def `TypeOfPhone` as type_of_phone(self, p: int) -> PhoneType:
        """Looks up the type of the given phone id.

        Args:
          p (int): The input phone id.

        Returns:
          PhoneType: The type of input phone id.
        """

      phone_to_type: list<PhoneType>
      """Mapping from phone ids to phone types."""
      silence_label: int
      """Label for silence arcs."""
      partial_word_label: int
      """Label for partial word arcs at the end of "forced-out" utterances."""
      reorder: bool
      """Whether lattice was created from a graph with reorder option set."""


    def `WordAlignLattice` as word_align_lattice(
      lat: CompactLatticeVectorFst, tmodel: TransitionModel,
      info: WordBoundaryInfo, max_states: int)
      -> (success: bool, lat_out: CompactLatticeVectorFst):
      """Aligns the word labels and transition-ids.

      Aligns compact lattice so that each arc has the transition-ids on it that
      correspond to the word that is on that arc. It is OK for the lattice to
      have epsilon arcs for optional silences.

      Args:
        lat (CompactLatticeVectorFst): The input lattice.
        tmodel (TransitionModel): The transition model.
        info (WordBoundaryInfo): The word boundary information.
        max_states (int): Maximum #states allowed in the output lattice. If
          `max_states > 0` and the #states of the output will be greater than
          `max_states`, this function will abort the computation, return False
          and output an empty lattice.

      Returns:
        A tuple representing the return value and the output lattice. The
        return value is set to True if the operation was successful, False if
        some kind of problem was detected, e.g. transition-id sequences in the
        lattice were incompatible with the word boundary information, or the
        lattice seems to have been "forced out" (did not reach end state,
        resulting in partial words at the end).

      Note:
        We don't expect silence inside words, or empty words (words with no
        phones), and we expect the word to start with a wbegin_phone, to end
        with a wend_phone, and to possibly have winternal_phones inside (or to
        consist of just one wbegin_and_end_phone).

      Note:
        If this function returns False, it doesn't mean the input lattice is
        necessarily bad: it might just be that the lattice was "forced out" as
        the end-state was not reached during decoding, and in this case the
        output might still be usable.
      """

    def `TestWordAlignedLattice` as test_word_aligned_lattice(
      lat: CompactLatticeVectorFst, tmodel: TransitionModel,
      info: WordBoundaryInfo, aligned_lat: CompactLatticeVectorFst):
      """Verifies the output of `word_align_lattice`.

      Args:
        lat (CompactLatticeVectorFst): The input lattice.
        tmodel (TransitionModel): The transition model.
        info (WordBoundaryInfo): The word boundary information.
        aligned_lat (CompactLatticeVectorFst): The word-aligned lattice.

      Raises:
        RuntimeError: If verification fails.
      """
