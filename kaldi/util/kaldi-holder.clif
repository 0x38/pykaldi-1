from "matrix/kaldi-vector-clifwrap.h" import *
from "matrix/kaldi-matrix-clifwrap.h" import *

from "util/kaldi-holder.h":
  namespace `kaldi`:
    ############################################################################
    # KaldiObjectHolders
    ############################################################################
    class `KaldiObjectHolder<Vector<float>>` as KaldiVectorHolder:
      T:Vector = property(`Value`)
      
      def Clear(self)

      # FIXME (VM):
      # The argument other in this method get wrapped as
      # ::kaldi::KaldiObjectHolder< ::kaldi::KaldiObjectHolder<Vector<float> >::T> * arg1;
      # when it should be 
      # ::kaldi::KaldiObjectHolder< ::kaldi::KaldiObjectHolder<::kaldi::Vector<float> >::T> * arg1;
      # This raises an issue when building, since vector was not  
      # defined in the current scope.
      # def `Swap` as Swap(self, other:KaldiVectorHolder)
      
      # Note (VM):
      # But this works...
      def `ExtractRange` as ExtractRange(self, other:KaldiVectorHolder, range:str) -> bool

      @classmethod
      def IsReadInBinary(cls) -> bool

    class `KaldiObjectHolder<Matrix<float>>` as KaldiMatrixHolder:
      T:Matrix = property(`Value`)
      
      def Clear(self)

      # FIXME (VM):
      # See above
      # def `Swap` as Swap(self, other:KaldiMatrixHolder)

      def `ExtractRange` as ExtractRange(self, other:KaldiMatrixHolder, range:str) -> bool

      @classmethod
      def IsReadInBinary(cls) -> bool

    ############################################################################
    # BasicType holders
    ############################################################################
    class `BasicHolder<bool>` as BoolHolder:
      T:bool = property(`Value`)

      def Clear(self)
      
      def `Swap` as Swap(self, other:BoolHolder)
      def `ExtractRange` as ExtractRange(self, other:BoolHolder, range:str) -> bool

      @classmethod
      def IsReadInBinary(cls) -> bool

    class `BasicHolder<int>` as IntHolder:
      T:int = property(`Value`)

      def Clear(self)

      # TODO (VM):
      # Manage other cases in python
      def `Swap` as Swap(self, other:IntHolder)
      def `ExtractRange` as ExtractRange(self, other:IntHolder, range:str) -> bool

      @classmethod
      def IsReadInBinary(cls) -> bool

    class `BasicHolder<float>` as FloatHolder:
      T:float = property(`Value`)

      def Clear(self)

      # TODO (VM):
      # Manage other cases in python
      def `Swap` as Swap(self, other:FloatHolder)
      def `ExtractRange` as ExtractRange(self, other:FloatHolder, range:str) -> bool

      @classmethod
      def IsReadInBinary(cls) -> bool

    class TokenHolder:
      T:str = property(`Value`)

      def Clear(self)
      
      def `Swap` as Swap(self, other:TokenHolder)
      def `ExtractRange` as ExtractRange(self, other:TokenHolder, range:str) -> bool

      @classmethod
      def IsReadInBinary(cls) -> bool

    ############################################################################
    # Vector<Basic Type> Holders
    ############################################################################
    # TODO (VM)


    def `ExtractObjectRange` as ExtractMatrixRange(input:Matrix, range:str, m:Matrix) -> bool

    def `ExtractObjectRange` as ExtractVectorRange(input:Vector, range:str, v:Vector) -> bool

    def ExtractRangeSpecifier(rxfilename_with_range:str, data_rxfilename:str, range:str) -> bool
