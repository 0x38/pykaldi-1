from "matrix/matrix-common_clifwrap.h" import *
from "matrix/kaldi-vector_clifwrap.h" import *

from "matrix/kaldi-matrix.h":
  namespace `kaldi`:
    class `MatrixBase<float>` as MatrixBase:

      num_rows_: `MatrixIndexT` as int = property(`NumRows`)
      num_cols_: `MatrixIndexT` as int = property(`NumCols`)

      def Stride(self) -> int

      def SizeInBytes(self) -> int

      # def Data(self) -> float*
      # def RowData(self) -> float*

      # FIXME(Dogan): This fails becasue SubVector assignment op is private.
      # @sequential
      # def `Row` as __getitem__(self, r: int) -> SubVector

      # FIXME(Dogan): Argument order is reversed in C++. Handle in Python.
      # @sequential
      # def `CopyRowFromVec` as __setitem__(self, r: int, v: VectorBase)

      # def Index

      def SetZero(self)

      def SetUnit(self)

      def SetRandn(self)

      def SetRandUniform(self)

      # Copying functions #
      def CopyFromMat(self, M:MatrixBase, trans:MatrixTransposeType = default)

      # FIXME (VM): Missing definitions
      # def `CopyFromMat` as CopyFromCudaMat(self, M:CuMatrixBase, trans:MatrixTransposeType = default)
      # def CopyFromMat(self, M:CompressedMatrix);
      # def CopyFromSp(self, M:SpMatrix);
      # def CopyFromTp(self, M:TpMatrix, trans:MatrixTransposeType = default)

      # FIXME (VM):
      # def CopyRowsFromVec(self, v:VectorBase)

      # def `CopyRowsFromVec` as CopyRowFromCudaVec(self, v:CuVector)

      # FIXME (VM):
      # Cannot implement
      # void CopyRowsFromVec(const VectorBase<OtherReal> &v);

      def `CopyColsFromVec` as CopyColsFromVec(self, v:VectorBase)

      def CopyColFromVec(self, v:VectorBase, col:`MatrixIndexT` as int)

      def CopyRowFromVec(self, v:VectorBase, row:`MatrixIndexT` as int)

      def CopyDiagFromVec(self, v:VectorBase)

      # Accessing sub-parts of matrix #


      # Special functions #

      def Sum(self) -> float

      def Trace(self, check_square: bool = default) -> float

      def Max(self) -> float

      def Min(self) -> float

      def `MulElements` as __mult__(self, A: MatrixBase)

      def `DivElements` as __div__(self, A: MatrixBase)

      def Scale(self, alpha: float)

      def `Max` as MaxWithMat(self, A: MatrixBase)

      def `Min` as MinWithMat(self, A: MatrixBase)

      def MulColsVec(self, scale: VectorBase)

      def MulRowsVec(self, scale: VectorBase)

      def MulRowsGroupMat(self, src: MatrixBase)

      # FIXME:
      # def LogDet(self, det_sign: float) -> float
      # def Invert(self, log_det: float = default, det_sign: float = default, inverse_needed: bool = default)
      # def InvertDouble(self, logDet: float = default, det_sign: float = default, inverse_needed: bool = default)

      def InvertElements(self)

      def Transpose(self)

      def CopyCols(self, src: MatrixBase, indices: int)

      def CopyRows(self, src: MatrixBase, indices: int)

      def AddCols(self, src: MatrixBase, indices: int)

      # FIXME:
      # void CopyRows(const Real *const *src);
      # void CopyToRows(Real *const *dst) const;

      def AddRows(self, alpha: float, src: MatrixBase, indexes: int)

      # FIXME:
      # void AddRows(Real alpha, const Real *const *src);
      # void AddToRows(Real alpha, Real *const *dst) const;
      #

      def ApplyFloor(self, floor_val: float)

      def ApplyCeiling(self, ceiling_val: float)

      def ApplyLog(self)

      def ApplyExp(self)

      def ApplyPow(self, power: float)

      def ApplyPowAbs(self, power: float, include_sign: bool = default)

      def ApplyHeaviside(self)

      # FIXME:
      #  This doesn't work because VectorBase<Real>() is protected
      # def Eig(self, P: MatrixBase) -> (eigs_real: VectorBase, eigs_imag: VectorBase)

      def Power(self, pow: float) -> bool

      # FIXME:
      # void Svd(VectorBase<Real> *s, MatrixBase<Real> *U, MatrixBase<Real> *Vt) const;

      def Svd(self, s: VectorBase)

      def MinSingularValue(self) -> float

      def TestUninitialized(self)

      def Cond(self) -> float

      def IsSymmetric(self, cutoff: float = default) -> bool

      def IsDiagonal(self, cutoff: float = default) -> bool

      def IsUnit(self, cutoff: float = default) -> bool

      def IsZero(self, cutoff: float = default) -> bool

      def FrobeniusNorm(self) -> float

      def ApproxEqual(self, other: MatrixBase, tol: float = default) -> bool

      def Equal(self, other: MatrixBase) -> bool

      def LargestAbsElem(self) -> float

      def LogSumExp(self, prune: float = default) -> float

      def ApplySoftMax(self) -> float

      def Sigmoid(self, src: MatrixBase)

      def Heaviside(self, src: MatrixBase)

      def SoftHinge(self, src: MatrixBase)

      def GroupPnorm(self, src: MatrixBase, power: float)

      # FIXME:
      # This doesn't follow Google conventions for C++,
      # where inputs must come before any output
      # def GroupPnormDeriv(self, input: MatrixBase, output: MatrixBase, power: float)

      def GroupMax(self, src: MatrixBase)

      # FIXME:
      # def GroupMaxDeriv(self, input: MatrixBase) -> (output: MatrixBase)

      def Tanh(self, src: MatrixBase)

      def DiffSigmoid(self, value: MatrixBase, diff: MatrixBase)

      def DiffTanh(self, value: MatrixBase, diff: MatrixBase)

      def SymPosSemiDefEig(self, s: VectorBase, P: MatrixBase, check_thresh: float = default)

      # FIXME:
      # What to do here?
      # friend Real kaldi::TraceMatMat<Real>(const MatrixBase<Real> &A,
      # const MatrixBase<Real> &B, MatrixTransposeType trans);  // tr (A B)

      def Add(self, alpha: float)

      def AddToDiag(self, alpha: float)

      def AddVecVec(self, alpha: float, a: VectorBase, b: VectorBase)

      #   template<typename OtherReal>
      #   void AddVecVec(const Real alpha, const VectorBase<OtherReal> &a,
      #       const VectorBase<OtherReal> &b);

      # Note (VM):
      # I'm skipping the templated function, assuming we only deal with float
      def AddVecToRows(self, alpha: float, v: VectorBase)

      def AddVecToCols(self, alpha: float, v: VectorBase)

      def AddMat(self, alpha: float, M: MatrixBase, transA: MatrixTransposeType = default)

      def SymAddMat2(self, alpha: float, M: MatrixBase, transA: MatrixTransposeType, beta: float)

      def AddDiagVecMat(self, alpha: float, v: VectorBase, M: MatrixBase, transM: MatrixTransposeType, beta: float = default)

      def AddMatDiagVec(self, alpha: float, M: MatrixBase, transM: MatrixTransposeType, v: VectorBase, beta: float = default)

      def AddMatMatElements(self, alpha: float, A: MatrixBase, B: MatrixBase, beta: float)

      # FIXME:
      # Missing SpMatrix definition
      # def AddSp(self, alpha: float, S:SpMatrix)

      def AddMatMat(self, alpha: float, A: MatrixBase, transA: MatrixTransposeType, B: MatrixBase, transB: MatrixTransposeType, beta: float)

      def SetMatMatDivMat(self, A: MatrixBase, B: MatrixBase, C: MatrixBase)

      def AddMatSmat(self, alpha: float, A: MatrixBase, transA: MatrixTransposeType, B: MatrixBase, transB: MatrixTransposeType, beta: float)

      def AddSmatMat(self, alpha: float, A: MatrixBase, transA: MatrixTransposeType, B: MatrixBase, transB: MatrixTransposeType, beta: float)

      def AddMatMatMat(self, alpha: float, A: MatrixBase, transA: MatrixTransposeType, B: MatrixBase, transB: MatrixTransposeType, C: MatrixBase, transC: MatrixTransposeType, beta: float)

      # FIXME:
      # Missing definitions
      # def AddSpMat(self, alpha: float, A:SpMatrix, B: MatrixBase, transB: MatrixTransposeType, beta: float)
      # def AddTpMat(self, alpha: float, A:TpMatrix, transA: MatrixTransposeType, B: MatrixBase, transB: MatrixTransposeType, beta: float)
      # def AddMatSp(self, alpha: float, A: MatrixBase, transA: MatrixTransposeType, B:SpMatrix, beta: float)
      # def AddMatTp(self, alpha: float, A: MatrixBase, transA: MatrixTransposeType, B:TpMatrix, transB: MatrixTransposeType, beta: float)
      # def AddTpTp
      # def AddSpSp

      def CopyLowerToUpper(self)

      def CopyUpperToLower(self)

      def OrthogonalizeRows(self)

      # FIXME: How?!
      # void Read(std::istream & in, bool binary, bool add = false);
      # void Write(std::ostream & out, bool binary) const;


    class `Matrix<float>` as Matrix(MatrixBase):

      @add__init__
      def `Matrix` as MatrixWithSize(self, r: int, c: int,
                                     resize_type: MatrixResizeType = default,
                                     stride_type: MatrixStrideType = default)

      # NOTE: Both of these methods need to be defined in the derived class, or
      # delitem code corrupts the getitem code generated for the base class.
      # See: https://github.com/google/clif/issues/8
      # @sequential
      # def `Row` as __getitem__(self, r: int) -> SubVector
      #
      # @sequential
      # def `RemoveRow` as __delitem__(self, r: int)

      # FIXME (VM):
      # Missing definition
      # @add__init__
      # explicit Matrix(const CuMatrixBase<OtherReal> &cu,
                  # MatrixTransposeType trans = kNoTrans);

      def Swap(self, other:Matrix)

      # def `Swap` as SwapCuda(self, mat:CuMatrix)

      # FIXME (VM):
      # This doesnt work because function cannot be specialized
      # @add__init__
      # def `Matrix` as FromMatrix(self, M:MatrixBase, trans:MatrixTransposeType = default)



    # FIXME (VM):
    # Circular definition
    # class `SubMatrix<float>` as SubMatrix(MatrixBase):
        # pass

    # FIXME (VM):
    # This doesn't work because "Function template can't be specialized with these arguments.
    #                            Clif expects it in the file matrix/kaldi-matrix.h but found it at 
    #                            /home/dogan/tools/kaldi/src/base/kaldi-math.h:262:1"
    # def ApproxEqual(A:MatrixBase, B:MatrixBase, tol:float = default) -> bool


    def TraceMatMat(A: MatrixBase, B: MatrixBase,
                    trans: MatrixTransposeType = default) -> float
