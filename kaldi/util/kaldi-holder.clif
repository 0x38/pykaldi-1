from "matrix/kaldi-vector-clifwrap.h" import *
from "matrix/kaldi-matrix-clifwrap.h" import *

from "util/kaldi-holder.h":
  namespace `kaldi`:
    ############################################################################
    # KaldiObjectHolders
    ############################################################################
    
    class `KaldiObjectHolder<Vector<float>>` as KaldiVectorHolder:
      T:Vector = property(`Value`)
      
      def Clear(self)

      # FIXME (VM):
      # The argument other in this method get wrapped as
      # ::kaldi::KaldiObjectHolder< ::kaldi::KaldiObjectHolder<Vector<float> >::T> * arg1;
      # when it should be 
      # ::kaldi::KaldiObjectHolder< ::kaldi::KaldiObjectHolder<::kaldi::Vector<float> >::T> * arg1;
      # This raises an issue when building, since vector was not  
      # defined in the current scope.
      # def `Swap` as Swap(self, other:KaldiVectorHolder)

      # Note (VM):
      # But this works...
      def `ExtractRange` as ExtractRange(self, other:KaldiVectorHolder, range:str) -> bool

      @classmethod
      def IsReadInBinary(cls) -> bool

    class `KaldiObjectHolder<Matrix<float>>` as KaldiMatrixHolder:
      T:Matrix = property(`Value`)
      
      def Clear(self)

      # FIXME (VM):
      # See above
      # def `Swap` as Swap(self, other:KaldiMatrixHolder)

      def `ExtractRange` as ExtractRange(self, other:KaldiMatrixHolder, range:str) -> bool

      @classmethod
      def IsReadInBinary(cls) -> bool

    ############################################################################
    # BasicType holders
    ############################################################################
    class `BasicHolder<bool>` as BoolHolder:
      T:bool = property(`Value`)

      def Clear(self)
      
      def `Swap` as Swap(self, other:BoolHolder)
      def `ExtractRange` as ExtractRange(self, other:BoolHolder, range:str) -> bool

      @classmethod
      def IsReadInBinary(cls) -> bool

    class `BasicHolder<int>` as IntHolder:
      T:int = property(`Value`)

      def Clear(self)

      def `Swap` as Swap(self, other:IntHolder)
      def `ExtractRange` as ExtractRange(self, other:IntHolder, range:str) -> bool

      @classmethod
      def IsReadInBinary(cls) -> bool

    class `BasicHolder<float>` as FloatHolder:
      T:float = property(`Value`)

      def Clear(self)

      def `Swap` as Swap(self, other:FloatHolder)
      def `ExtractRange` as ExtractRange(self, other:FloatHolder, range:str) -> bool

      @classmethod
      def IsReadInBinary(cls) -> bool

    class TokenHolder:
      T:str = property(`Value`)

      def Clear(self)
      
      def `Swap` as Swap(self, other:TokenHolder)
      def `ExtractRange` as ExtractRange(self, other:TokenHolder, range:str) -> bool

      @classmethod
      def IsReadInBinary(cls) -> bool

    ############################################################################
    # Vector<Basic Type> Holders
    ############################################################################
    
    # Note (VM):
    # This fails due to std::vector<bool> not being like
    #   the other vectors.
    # Since you cannot get a reference via auto& for a vector<bool>,
    #   clif produces an error.
    # class `BasicVectorHolder<bool>` as BoolVectorHolder:
    #   T:list<bool> = property(`Value`)

    #   def Clear(self)

    #   def `Swap` as Swap(self, other:BoolVectorHolder)

    #   def `ExtractRange` as ExtractRange(self, other:BoolVectorHolder, range:str) -> bool

    #   @classmethod
    #   def IsReadInBinary(cls) -> bool

    class `BasicVectorHolder<float>` as FloatVectorHolder:
      T:list<float> = property(`Value`)

      def Clear(self)

      def `Swap` as Swap(self, other:FloatVectorHolder)

      def `ExtractRange` as ExtractRange(self, other:FloatVectorHolder, range:str) -> bool

      @classmethod
      def IsReadInBinary(cls) -> bool

    class `BasicVectorHolder<int>` as IntVectorHolder:
      T:list<int> = property(`Value`)

      def Clear(self)

      def `Swap` as Swap(self, other:IntVectorHolder)

      def `ExtractRange` as ExtractRange(self, other:IntVectorHolder, range:str) -> bool

      @classmethod
      def IsReadInBinary(cls) -> bool

    class TokenVectorHolder:
      T:list<str> = property(`Value`)

      def Clear(self)

      def `Swap` as Swap(self, other:TokenVectorHolder)

      def `ExtractRange` as ExtractRange(self, other:TokenVectorHolder, range:str) -> bool

      @classmethod
      def IsReadInBinary(cls) -> bool

    ############################################################################
    # VectorVector<Basic Type> Holders
    ############################################################################
    
    # Note (VM):
    # See previous note
    # class `BasicVectorVectorHolder<bool>` as BoolVectorVectorHolder:
    #   T:list<list<bool>> = property(`Value`)

    #   def Clear(self)

    #   def `Swap` as Swap(self, other:BoolVectorVectorHolder)

    #   def `ExtractRange` as ExtractRange(self, other:BoolVectorVectorHolder, range:str) -> bool

    #   @classmethod
    #   def IsReadInBinary(cls) -> bool

    class `BasicVectorVectorHolder<float>` as FloatVectorVectorHolder:
      T:list<list<float>> = property(`Value`)

      def Clear(self)

      def `Swap` as Swap(self, other:FloatVectorVectorHolder)

      def `ExtractRange` as ExtractRange(self, other:FloatVectorVectorHolder, range:str) -> bool

      @classmethod
      def IsReadInBinary(cls) -> bool

    class `BasicVectorVectorHolder<int>` as IntVectorVectorHolder:
      T:list<list<int>> = property(`Value`)

      def Clear(self)

      def `Swap` as Swap(self, other:IntVectorVectorHolder)

      def `ExtractRange` as ExtractRange(self, other:IntVectorVectorHolder, range:str) -> bool

      @classmethod
      def IsReadInBinary(cls) -> bool

    ############################################################################
    # PairVector<Basic Type> Holders
    ############################################################################
    
    # Note (VM):
    # See previous note
    # class `BasicPairVectorHolder<bool>` as BoolPairVectorHolder:
    #   T:list<tuple<bool, bool>> = property(`Value`)

    #   def Clear(self)

    #   def `Swap` as Swap(self, other:BoolPairVectorHolder)

    #   def `ExtractRange` as ExtractRange(self, other:BoolPairVectorHolder, range:str) -> bool

    #   @classmethod
    #   def IsReadInBinary(cls) -> bool

    class `BasicPairVectorHolder<float>` as FloatPairVectorHolder:
      T:list<tuple<float, float>> = property(`Value`)

      def Clear(self)

      def `Swap` as Swap(self, other:FloatPairVectorHolder)

      def `ExtractRange` as ExtractRange(self, other:FloatPairVectorHolder, range:str) -> bool

      @classmethod
      def IsReadInBinary(cls) -> bool

    class `BasicPairVectorHolder<int>` as IntPairVectorHolder:
      T:list<tuple<int, int>> = property(`Value`)

      def Clear(self)

      def `Swap` as Swap(self, other:IntPairVectorHolder)

      def `ExtractRange` as ExtractRange(self, other:IntPairVectorHolder, range:str) -> bool

      @classmethod
      def IsReadInBinary(cls) -> bool

    


    def `ExtractObjectRange` as ExtractMatrixRange(input:Matrix, range:str, m:Matrix) -> bool

    def `ExtractObjectRange` as ExtractVectorRange(input:Vector, range:str, v:Vector) -> bool

    def ExtractRangeSpecifier(rxfilename_with_range:str, data_rxfilename:str, range:str) -> bool
