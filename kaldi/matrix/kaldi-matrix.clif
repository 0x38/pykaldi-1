from "util/iostream-clifwrap.h" import *
from "matrix/matrix-common-clifwrap.h" import *
from "matrix/kaldi-vector-clifwrap.h" import *

from "matrix/kaldi-matrix.h":
  namespace `kaldi`:
    class `MatrixBase<float>` as MatrixBase:
      num_rows: int = property(`NumRows`)
      """Number of rows (zero for empty matrix)."""
      num_cols: int = property(`NumCols`)
      """Number of columns (zero for empty matrix)."""
      stride: int = property(`Stride`)
      """Row stride (distance in memory between each row, >= num_cols)."""

      def `SizeInBytes` as size_in_bytes(self) -> int:
        """Returns the size in bytes of the data held by the matrix."""

      # Note: It is probably a bad idea to expose these in Python.
      # def Data(self) -> float*
      # def RowData(self) -> float*

      # Note: CopyRowFromVec functionality is provided in Python with
      # the __setitem__ method.

      def `operator()` as _getitem(self, row:int, col:int) -> float

      def `Set` as _setitem(self, row:int, col:int, value:float)

      def `SetZero` as set_zero(self):
        """Fills matrix with zeros."""

      def `SetUnit` as set_unit(self):
        """Fills diagonal elements with ones, off-diagonal elements with zeros.

        Note:
          Works for non-square matrices too.
        """

      def `SetRandn` as set_randn(self):
        """Fills matrix with samples from the standard normal distribution."""

      def `SetRandUniform` as set_rand(self):
        """Fills matrix with samples from the standard uniform distribution."""

      # Copy methods
      def `CopyFromMat` as _copy_from_mat(self, M:MatrixBase,
                                          trans:MatrixTransposeType = default):
        """Copy elements from another matrix of the same size.

        Args:
          M(MatrixBase): The matrix to copy from.
          trans(MatrixTransposeType): TRANS if the matrix is to be transposed,
            NO_TRANS otherwise (default).

        Raises:
          Error in case of dimension mismatch.
        """

      # def `CopyFromMat` as CopyFromCudaMat(
      #     self, M:CuMatrixBase, trans:MatrixTransposeType = default)


      # Note: These are wrapped in kaldi-matrix-ext.{h,clif}.
      # def CopyFromMat(self, M:CompressedMatrix)
      # def CopyFromSp(self, M:SpMatrix)
      # def CopyFromTp(self, M:TpMatrix,
      #                trans:MatrixTransposeType = default)

      # def `CopyRowsFromVec` as CopyRowFromCudaVec(self, v:CuVector)

      def `CopyRowsFromVec` as copy_rows_from_vec(self, v:VectorBase):
        """Copy row elements from a vector.

        This function has two modes of operation. If v.size == rows * cols,
        then it treats the vector as a row-by-row concatenation of a matrix
        and copies to self. if v.size == cols, it sets each row of self to a
        copy of v.

        Args:
          v(VectorBase): The vector to copy from.

        Raises:
          Error in case of dimension mismatch.
        """

      def `CopyColsFromVec` as copy_cols_from_vec(self, v:VectorBase):
        """Copy column elements from a vector.

        This function has two modes of operation. If v.size == rows * cols,
        then it treats the vector as a col-by-col concatenation of a matrix
        and copies to self. if v.size == rows, it sets each col of self to a
        copy of v.

        Args:
          v(VectorBase): The vector to copy from.

        Raises:
          Error in case of dimension mismatch.
        """

      def `CopyColFromVec` as copy_col_from_vec(self, v:VectorBase, col:int):
        """Copy vector into a specific column of this matrix.

        Args:
          v(VectorBase): The vector to copy from.
          col(int): Indexes the column of the matrix. Indexing starts from 0.

        Raises:
          Error in case of dimension mismatch.
        """

      def `CopyRowFromVec` as copy_row_from_vec(self, v:VectorBase, row:int):
        """Copy vector into a specific row of this matrix.

        Args:
          v(VectorBase): The vector to copy from.
          col(int): Indexes the column of the matrix. Indexing starts from 0.

        Raises:
          Error in case of dimension mismatch.
        """

      def `CopyDiagFromVec` as copy_diag_from_vec(self, v:VectorBase):
        """Copy vector into the diagonal of this matrix.

        Args:
          v(VectorBase): The vector to copy from.

        Raises:
          Error in case of dimension mismatch.
        """

      # Accessing sub-parts of matrix #
      # Note (VM):
      # Implemented in child class Matrix<Real>

      # Special functions #

      def `Sum` as sum(self) -> float:
        """Returns the sum of all elements in the matrix."""

      def `Trace` as trace(self, check_square: bool = default) -> float:
        """Returns the trace of the matrix.

        If matrix is not square it will return the trace of the square matrix
        formed from the minimum dimension, e.g. if the matrix is 3x5 it will
        calculate the trace of the submatrix 3x3.

        Args:
          check_square(bool): Check if matrix is square (default: True).

        Raises:
          Error if the matrix is not square and check_square is True.
        """

      def `Max` as max(self) -> float:
        """Returns the maximum element of the matrix."""

      def `Min` as min(self) -> float:
        """Returns the minimum element of the matrix."""

      def `MulElements` as mul_elements(self, A: MatrixBase):
        """Element by element multiplication with matrix A.

        Args:
          A(MatrixBase): A matrix.

        Raises:
          Error in case of dimension mismatch.
        """

      def `DivElements` as div_elements(self, A: MatrixBase):
        """Element by element division with matrix A,
             e.g. self(i,j) = self(i,j)/A(i,j) for all i,j.

        Args:
          A(MatrixBase): A matrix

        Raises:
          Error in case of dimension mismatch
        """

      def `Scale` as scale(self, alpha: float):
        """Scale all elements of the matrix by alpha

        Args:
          alpha(float): A scaling constant
        """

      def `Max` as max_with_mat(self, A: MatrixBase):
        """Performs the operation :math:`M_{ij} = max(M_{ij}, A_{ij})`.

        Args:
          A(MatrixBase): A matrix

        Raises:
          Error in case of dimension mismatch
        """

      def `Min` as min_with_mat(self, A: MatrixBase):
        """Performs the operation :math:`M_{ij} = min(M_{ij}, A_{ij})`.

        Args:
          A(MatrixBase): A matrix

        Raises:
          Error in case of dimension mismatch
        """

      def `MulColsVec` as mul_cols_vec(self, scale: VectorBase):
        """Performs the operation :math:`M_{ij} = scale_{j} M_{ij}`.

        Args:
          scale(VectorBase): A scaling vector

        Raises:
          Error in case of dimension mismatch
        """

      def `MulRowsVec` as mul_rows_vec(self, scale: VectorBase):
        """Performs the operation :math:`M_{ij} = scale_{i} M_{ij}`.

        Args:
          scale(VectorBase): A scaling vector

        Raises:
          Error in case of dimension mismatch
        """

      def `MulRowsGroupMat` as mul_rows_group_mat(self, src: MatrixBase):
        """Scales matrix with another matrix.

        Divides each row of self into src.num_cols equal groups, and then
        scales i'th row's j'th group of elements with src(i, j).

        Args:
          src(MatrixBase): A scaling Matrix

        Raises:
          Error if self.num_rows != src.num_rows || self.num_cols % src.num_cols !=0
        """

      # FIXME(Pavlos):
      # Need C++ wrappers for these functions. Moreover they do not feel like ``pythonic''
      #
      # def LogDet(self, det_sign: `float` as float = default) -> float
      #
      # def Invert(self, log_det: `float` as float = default,
      #            det_sign: `float` as float = default,
      #            inverse_needed: bool = default)
      #   """Matrix inverse
      #
      #     Args:
      #         log_det(float): Will store the log determinant
      #         det_sign(float): Will store the sign of the determinant, 1 or -1.
      #         inverse_needed(bool): If false it will return garbage. Default is true
      #
      #     Raises:
      #         Error if matrix is not square
      #   """
      #
      # def InvertDouble(self, logDet: `float` as float = default,
      #                  det_sign: `float` as float = default,
      #                  inverse_needed: bool = default)
      #   """Matrix inverse
      #
      #     Args:
      #         logDet(float): Will store the log determinant
      #         det_sign(float): Will store the sign of the determinant, 1 or -1.
      #         inverse_needed(bool): If false it will return garbage
      #
      #     Raises:
      #         Error if matrix is not square
      #   """

      def `InvertElements` as invert_elements(self):
        """Inverts all the elements of the matrix. self(i,j)=1/self(i,j)."""

      def `Transpose` as transpose(self):
        """Transposes the elements of the matrix. self(i,j)=self(j,i)."""

      # FIXME(Pavlos):
      # Indices should not be int, they are supposed to be an array
      # def CopyCols(self, src: MatrixBase, indices: int)
      # def CopyRows(self, src: MatrixBase, indices: int)
      # def AddCols(self, src: MatrixBase, indices: int)

      # FIXME:
      # void CopyRows(const Real *const *src);
      # void CopyToRows(Real *const *dst) const;
      # def AddRows(self, alpha: float, src: MatrixBase, indexes: int)

      # FIXME:
      # void AddRows(Real alpha, const Real *const *src);
      # void AddToRows(Real alpha, Real *const *dst) const;

      def `ApplyFloor` as apply_floor(self, floor_val: float):
        """Applies floor to all elements. If self(i,j)<floor then self(i,j)=floor.

          Args:
              floor(float): The floor value to check against.
        """

      def `ApplyCeiling` as apply_ceiling(self, ceiling_val: float):
        """Applies floor to all elements. If self(i,j)>ceiling then self(i,j)=ceiling.

          Args:
              ceiling(float): The ceiling value to check against.
        """

      def `ApplyLog` as apply_log(self):
        """Apply natural log to all elements."""

      def `ApplyExp` as apply_exp(self):
        """Apply exponential to each value in vector."""

      def `ApplyPow` as apply_pow(self, power: float):
        """Take all elements of matrix to a power.

          Args:
              power(float): The power which we apply to all elements of self

          Raises:
              Error if you try to handle imaginary numbers
              (e.g. square root of a negative) or in case of overflow.
        """

      def `ApplyPowAbs` as apply_pow_abs(self, power: float, include_sign: bool = default):
        """Take the absolute value of all elements of a vector to a power.
             Include the sign of the input element if include_sign == true.
             For example, if self=(-3,2) then for power=2 and include_sign=true
             we would have self=(-9,4). If power is negative and the
             input value is zero, the output is set zero.

          Args:
              power(float): The power which we apply to all alements of self
              include_sign(bool): True if we include the sign of the input element.

          Raises:
              Error if we have overflows or underflows.
        """

      def `ApplyHeaviside` as apply_heaviside(self):
        """Applies the Heaviside step function (x > 0 ? 1 : 0) to all matrix elements."""

      # FIXME(pavlos):
      # Need C++ wrappers for this
      #
      # def Eig(self, P: MatrixBase, eigs_real: VectorBase,
      #        eigs_imag: VectorBase)
      #   """Eigenvalue Decomposition of a square matrix into the form  P D P^{-1}.
      #       Be careful: the relationship of D to the eigenvalues we output is
      #       slightly complicated, due to the need for P to be real.  In the symmetric
      #       case D is diagonal and real, but in
      #       the non-symmetric case there may be complex-conjugate pairs of eigenvalues.
      #       In this case, for the equation (*this) = P D P^{-1} to hold, D must actually
      #       be block diagonal, with 2x2 blocks corresponding to any such pairs.  If a
      #       pair is lambda +- i*mu, D will have a corresponding 2x2 block
      #       [lambda, mu; -mu, lambda].
      #       Note that if the input matrix (*this) is non-invertible, P may not be invertible
      #       so in this case instead of the equation (*this) = P D P^{-1} holding, we have
      #       instead (*this) P = P D.
      #
      #    Args:
      #        P(MatrixBase): Will store the P part of PDP^{-1} decomposition
      #        eigs_real(VectorBase): Will store the real part of the eigenvalues
      #        eigs_imga(VectorBase): Will store the imaginary part of the eigenvalues
      #   """

      def `Power` as power(self, pow: float) -> bool:
        """The Power method attempts to take the matrix to a power
             (e.g P^3=P*P*P) using a method that works in general for fractional
             and negative powers. The input matrix must be invertible and have
             reasonable condition (or we don't guarantee the results. The method is
             based on the eigenvalue decomposition. It will return false and
             leave the matrix unchanged, if at entry the matrix had real negative
             eigenvalues (or if it had zero eigenvalues and the power was negative).

          Args:
              pow(float): The power which we will apply

          Returns:
              True if operation was successful
        """

      # FIXME(pavlos):
      # Need C++ wrappers for this
      #
      # def DestructiveSvd(self, s: VectorBase, U: MatrixBase,
      #                    Vt: MatrixBase)
      #   """Singular value decomposition for NONSQUARE matrices.
      #        We assume num_rows >= num_cols, and we return the "skinny" Svd,
      #        i.e. the matrix in the middle is diagonal, and the one on the left
      #        is rectangular. In Svd, self = U*diag(S)*Vt. Null pointers for U and/or
      #        Vt at input mean we do not want that output. We expect that
      #        S.dim == num_rows, U is either NULL or num_rows by num_cols,
      #        and V is either NULL or num_cols by num_cols. The singular values are
      #        not sorted (use SortSvd for that). Note that Vt is the transpose of V.
      #
      #     Args:
      #         s(VectorBase): A vector of length num_rows of self.
      #                        It must be that s.dim = self.num_cols
      #         U(MatrixBase): A Matrix of size num_rowsxnum_cols of self which
      #                        will be filled with the U part of SVD
      #         Vt(MatrixBase): A Matrix of size num_colsxnum_cols of self which
      #                         will be filled with the U part of SVD
      #
      #     Raises:
      #         Error if self.num_rows<self.num_cols, or if U is not self.num_rows
      #         by self.num_cols of self, or if Vt is not self.num_cols by self.num_cols
      #   """
      #
      # def Svd(self, s: VectorBase, U: MatrixBase, Vt: MatrixBase)
      #   """Compute SVD self = U*diag(s)*Vt. Note that the V in the call is already
      #        transposed; the normal formulation is U diag(s) V^T. Null pointers
      #        for U or V mean we don't want that output (this saves computation time).
      #        The singular values are not sorted (use SortSvd for that).
      #
      #     Args:
      #         s(VectorBase): A vector of length min(self.num_rows, self.num_cols)
      #         U(MatrixBase): A Matrix of size num_rowsxnum_cols of self which
      #                        will be filled with the U part of SVD
      #         Vt(MatrixBase): A Matrix of size num_colsxnum_cols of self which
      #                         will be filled with the U part of SVD
      #   """
      #
      # def `Svd` as SingularValues(self, s: VectorBase)
      #   """Compute SVD but only retain the singular values.
      #
      #     Args:
      #         s(VectorBase): The vector where the singular values of self will be stored.
      #                        Its length must be min(self.num_rows, self.num_cols)
      #   """

      def `MinSingularValue` as min_singular_value(self) -> float:
        """Returns the smallest singular value."""

      # FIXME(pavlos):
      # This does nothing, it's designed to trigger Valgrind errors in kaldi.
      # Probably remove altogether
      #
      # def TestUninitialized(self)

      def `Cond` as cond(self) -> float:
        """Returns the condition number of the SVD computation."""

      def `IsSymmetric` as issymmetric(self, cutoff: float = default) -> bool:
        """Returns True if the matrix is symmetric."""

      def `IsDiagonal` as isdiagonal(self, cutoff: float = default) -> bool:
        """Checks if the matrix is diagonal. The nondiagonal elements
             must be less or equal to cutoff value.

          Args:
              cutoff(float): A cutoff value. Default is 1.0e-05

          Returns:
              True if sum(digonal_elements)*cutoff > sum(nondiagonal_elements),
              otherwise false
        """

      def `IsUnit` as isunit(self, cutoff: float = default) -> bool:
        """Checks if the matrix is identity-like. It does not have to be square.
             The nondiagonal elements must be less or equal to cutoff value,
             while the diagonal ones must be one.

          Args:
              cutoff(float): A cutoff value. Default is 1.0e-05

          Returns:
              True if the diagonal elements are 1 and sum(nondiagonal_elements)<=cutoff
        """

      def `IsZero` as iszero(self, cutoff: float = default) -> bool:
        """Checks if all elements are 0 (where 0 is the cutoff value).

          Args:
              cutoff(float): A cutoff value. Default is 1.0e-05

          Returns:
              True if it is a zero matrix
        """

      def `FrobeniusNorm` as frobenius_norm(self) -> float:
        """Returns the FrobeniusNorm of the matrix"""

      def `ApproxEqual` as approx_equal(self, other: MatrixBase, tol: float = default)
          -> bool:
        """Checks if self is equal with other by calculating the Frobenius
             norm of their difference.

          Args:
              other(MatrixBase): The matrix to check against
              tol(float): the tolerance

          Returns:
              True if ||(self-other)||_F <= tol * ||self||_F
        """

      def `Equal` as equal(self, other: MatrixBase) -> bool:
        """Tests for exact equality

          Args:
              other(MatrixBase): The matrix to check against

          Returns:
              True if self(i,j)=other(i,j) for all i,j
        """

      def `LargestAbsElem` as largest_abs_elem(self) -> float:
        """Returns the largest absolute value of the matrix's elements"""

      def `LogSumExp` as log_sum_exp(self, prune: float = default) -> float:
        """Returns log(sum(exp())) without exp overflow. If prune > 0.0, it uses
             a pruning beam, discarding terms less than (max - prune).

          Args:
              prune(float): A pruning value

          Returns:
             The log(sum(exp())) where the summation is over all the
             elements of the matrix
        """

      def `ApplySoftMax` as apply_softmax(self) -> float:
        """Apply the softmax function to every element of the matrix.

          Returns:
             The normalization of the softmax, i.e. sum(exp(self(i,j)))
        """

      def `Sigmoid` as sigmoid(self, src: MatrixBase):
        """Set each element to the sigmoid of the corresponding element of src.

          Args:
              src(MatrixBase): A matrix

          Raises:
              Error in case of dimension mismatch
        """

      def `Heaviside` as heaviside(self, src: MatrixBase):
        """Set each element to the heaviside of the corresponding element of src.

          Args:
              src(MatrixBase): A matrix

          Raises:
              Error in case of dimension mismatch
        """

      def `SoftHinge` as soft_hinge(self, src: MatrixBase):
        """Set each element of self as self(i,j) = log(1 + exp(src(i,j)))

          Args:
              src(MatrixBase): A matrix

          Raises:
              Error in case of dimension mismatch
        """

      def `GroupPnorm` as group_pnorm(self, src: MatrixBase, power: float):
        """See Also:
             :kaldi:`kaldi::GroupPnorm`
        """

      # def GroupPnormDeriv(self, input: MatrixBase, output: MatrixBase,
      #                     power: float)

      def `GroupMax` as group_max(self, src: MatrixBase):
        """See Also:
             :kaldi:`kaldi::GroupMax`
        """

      # FIXME(pavlos):
      # This needs a C++ wrapper
      #
      # def GroupMaxDeriv(self, input: MatrixBase, output: MatrixBase)
      #   """See Also:
      #     :kaldi:`kaldi::GroupMaxDeriv`
      #   """

      def `Tanh` as tanh(self, src: MatrixBase):
        """Set each element to the tanh of the corresponding element of src.

          Args:
              src(MatrixBase): A matrix

          Raises:
              Error in case of dimension mismatch
        """

      # FIXME(pavlos):
      # This needs a C++ wrapper
      #
      # def DiffSigmoid(self, value: MatrixBase, diff: MatrixBase)
      #
      # def DiffTanh(self, value: MatrixBase, diff: MatrixBase)
      #
      # def SymPosSemiDefEig(self, s: VectorBase, P: MatrixBase,
      #                     check_thresh: float = default)

      def `Add` as add(self, alpha: float):
        """Add a scalar alpha to each element of the matrix.

          Args:
             alpha(float): A scalar
        """

      def `AddToDiag` as add_to_diag(self, alpha: float):
        """Add a scalar alpha to the diagonal elements of the matrix.

          Args:
             alpha(float): A scalar
        """

      def `AddVecVec` as add_vec_vec(self, alpha: float, a: VectorBase, b: VectorBase):
        """Performs the operation :math:`M = M + \\alpha\\ a \\ b^T`.

          Args:
              alpha(float): A scaling constant
              a(VectorBase): A vector
              b(VectorBase): A vector
        """

      def `AddVecToRows` as add_vec_to_rows(self, alpha: float, v: VectorBase):
        """Performs the operation :math:`M_{ij} = M_{ij} + \\alpha\\ v_{j}`.

          Args:
              alpha(float): A scaling constant
              v(VectorBase): A vector

          Raises:
              Error in case of dimension mismatch
        """

      def `AddVecToCols` as add_vec_to_cols(self, alpha: float, v: VectorBase):
        """Performs the operation self(:,i) = self(:,i)+alpha*v for all i

          Args:
              alpha(float): A scaling constant
              v(VectorBase): A vector

          Raises:
              Error in case of dimension mismatch
        """

      def `AddMat` as add_mat(self, alpha: float, M: MatrixBase,
                 transA: MatrixTransposeType = default):
        """Performs the operation self = self+alpha*M or self = self+alpha*M^T

          Args:
              alpha(float): A scaling constant
              M(MatrixBase): A matrix
              transA(MatrixTransposeType): if kNoTrans(default) treat M as is,
                                           if kTrans transpose M before operation

          Raises:
              Error in case of dimension mismatch
        """

      def `SymAddMat2` as sym_add_mat2(self, alpha: float, M: MatrixBase,
                     transA: MatrixTransposeType, beta: float):
        """Performs the operation self = beta*self+alpha*M*M^T, for symmetric matrices.
             It only updates the lower triangle of *this. It will leave the
             matrix asymmetric; if you need it symmetric as a regular matrix,
             do CopyLowerToUpper().

          Args:
              alpha(float): A scaling constant
              M(MatrixBase): A matrix
              transA(MatrixTransposeType): if kNoTrans(default) treat M as is,
                                           if kTrans transpose M before operation
              beta(float): A scaling constant

          Raises:
              Error in case of dimension mismatch
        """

      def `AddDiagVecMat` as add_diag_vec_mat(self, alpha: float, v: VectorBase, M: MatrixBase,
                        transM: MatrixTransposeType,
                        beta: float = default):
        """Perform the operation self = beta*self+alpha*diag(v)*M

          Args:
              alpha(float): A scaling constant
              v(VectorBase): A vector
              M(MatrixBase): A matrix
              transA(MatrixTransposeType): if kNoTrans(default) treat M as is,
                                           if kTrans transpose M before operation
              beta(float): A scaling constant

          Raises:
              Error in case of dimension mismatch
        """


      def `AddMatDiagVec` as add_mat_diag_vec(self, alpha: float, M: MatrixBase,
                        transM: MatrixTransposeType, v: VectorBase,
                        beta: float = default):
        """Performs the operation self = beta*self+alpha*M*diag(v)

          Args:
              alpha(float): A scaling constant
              M(MatrixBase): A matrix
              transA(MatrixTransposeType): if kNoTrans(default) treat M as is,
                                           if kTrans transpose M before operation
              v(VectorBase): A vector
              beta(float): A scaling constant

          Raises:
              Error in case of dimension mismatch
        """


      def `AddMatMatElements` as add_mat_mat_elements(self, alpha: float, A: MatrixBase,
                            B: MatrixBase, beta: float):
        """Performs the operation :math:`M = \\beta\\ M + \\alpha\\ A \\odot B`.

          Args:
              alpha(float): A scaling constant
              A(MatrixBase): A matrix
              B(MatrixBase): A matrix
              beta(float): A scaling constant

          Raises:
              Error in case of dimension mismatch
        """

      # Note (VM):
      # Move to kaldi-matrix-ext.h
      # def AddSp(self, alpha: float, S:SpMatrix)

      def `AddMatMat` as add_mat_mat(self, alpha: float, A: MatrixBase,
                    transA: MatrixTransposeType, B: MatrixBase,
                    transB: MatrixTransposeType, beta: float):
        """Performs the operation self = beta*self+alpha*A*B.

          Args:
              alpha(float): A scaling constant
              A(MatrixBase): A matrix
              transA(MatrixTransposeType): if kNoTrans(default) treat A as is,
                                           if kTrans transpose A before operation
              B(MatrixBase): A matrix
              transB(MatrixTransposeType): if kNoTrans(default) treat B as is,
                                           if kTrans transpose B before operation
              beta(float): A scaling constant

          Raises:
              Error in case of dimension mismatch
        """

      def `SetMatMatDivMat` as set_mat_mat_div_mat(self, A: MatrixBase, B: MatrixBase,
                          C: MatrixBase):
        """Performs the operation self = A.*B./C, where ``.*'' and ``./''
             are elementwise multiplication and division. If c(i,j)==0
             then self(i,j) remains intact.

          Args:
              A(MatrixBase): A matrix
              B(MatrixBase): B matrix
              C(MatrixBase): C matrix

          Raises:
              Error in case of dimension mismatch
        """

      def `AddMatSmat` as add_mat_smat(self, alpha: float, A: MatrixBase,
                     transA: MatrixTransposeType, B: MatrixBase,
                     transB: MatrixTransposeType, beta: float):
        """A version of AddMatMat specialized for when B
             contains a lot of zeroes.

          Args:
              alpha(float): A scaling constant
              A(MatrixBase): A matrix
              transA(MatrixTransposeType): if kNoTrans(default) treat A as is,
                                           if kTrans transpose A before operation
              B(MatrixBase): A matrix
              transB(MatrixTransposeType): if kNoTrans(default) treat B as is,
                                           if kTrans transpose B before operation
              beta(float): A scaling constant

          Raises:
              Error in case of dimension mismatch
        """

      def `AddSmatMat` as add_smat_mat(self, alpha: float, A: MatrixBase,
                     transA: MatrixTransposeType, B: MatrixBase,
                     transB: MatrixTransposeType, beta: float):
        """A version of AddMatMat specialized for when A
             contains a lot of zeroes.

          Args:
              alpha(float): A scaling constant
              A(MatrixBase): A matrix
              transA(MatrixTransposeType): if kNoTrans(default) treat A as is,
                                           if kTrans transpose A before operation
              B(MatrixBase): A matrix
              transB(MatrixTransposeType): if kNoTrans(default) treat B as is,
                                           if kTrans transpose B before operation
              beta(float): A scaling constant

          Raises:
              Error in case of dimension mismatch
        """


      def `AddMatMatMat` as add_mat_mat_mat(self, alpha: float, A: MatrixBase,
                       transA: MatrixTransposeType, B: MatrixBase,
                       transB: MatrixTransposeType, C: MatrixBase,
                       transC: MatrixTransposeType, beta: float):
        """Performs the operation self = beta*self+alpha*A*B*C.

          Args:
              alpha(float): A scaling constant
              A(MatrixBase): A matrix
              transA(MatrixTransposeType): if kNoTrans(default) treat A as is,
                                           if kTrans transpose A before operation
              B(MatrixBase): A matrix
              transB(MatrixTransposeType): if kNoTrans(default) treat B as is,
                                           if kTrans transpose B before operation
              C(MatrixBase): A matrix
              transC(MatrixTransposeType): if kNoTrans(default) treat C as is,
                                           if kTrans transpose C before operation
              beta(float): A scaling constant

          Raises:
              Error in case of dimension mismatch
        """

      # Note (VM):
      # Move to kaldi-matrix-ext.h
      # def AddSpMat(self, alpha: float, A:SpMatrix, B: MatrixBase,
      #              transB: MatrixTransposeType, beta: float)
      # def AddTpMat(self, alpha: float, A:TpMatrix,
      #              transA: MatrixTransposeType, B: MatrixBase,
      #              transB: MatrixTransposeType, beta: float)
      # def AddMatSp(self, alpha: float, A: MatrixBase,
      #              transA: MatrixTransposeType, B:SpMatrix,
      #              beta: float)
      # def AddMatTp(self, alpha: float, A: MatrixBase,
      #              transA: MatrixTransposeType, B:TpMatrix,
      #              transB: MatrixTransposeType, beta: float)
      # def AddTpTp
      # def AddSpSp

      def `CopyLowerToUpper` as copy_lower_to_upper(self):
        """Copy lower triangle to upper triangle (symmetrize).

          Raises:
              Error if matrix is not square.
        """

      def `CopyUpperToLower` as copy_upper_to_lower(self):
        """Copy upper triangle to lower triangle (symmetrize)

          Raises:
              Error if matrix is not square.
        """

      def `OrthogonalizeRows` as orthogonalize_rows(self):
        """This function orthogonalizes the rows of a matrix using
             the Gram-Schmidt process. It will use random number generation
             to fill in rows with something nonzero, in cases where the
             original matrix was of deficient row rank.

          Raises:
              Error if self.num_rows > num_cols.
        """

      def `Read` as read(self, is: istream, binary: bool, add: bool = default):
        """Reads from C++ stream.

          Args:
              is(istream): The input straem.
              binary(bool): If the stream is binary.
              add(bool): True if you want to add the stream to self.
        """

      def `Write` as write(self, os: ostream, binary: bool):
        """Writes to C++ stream.

          Args:
              os(ostream): The output straem.
              binary(bool): If the stream is binary.
        """

    # Note: SubMatrix is wrapped manually. See matrix-ext.cc
    #
    # class `SubMatrix<float>` as SubMatrix(MatrixBase):
    #
    #     def __init__(self, T:MatrixBase, ro:int, r:int, co:int, c:int)
    #
    #     # Note:
    #     # We cannot wrap this constructor automatically since CLIF does
    #     # not support wrapping raw data pointers.
    #     # @add__init__
    #     # def `SubMatrix` as NewWithData(self, data:`float` as float,
    #                                      num_rows: int, num_cols: int,
    #                                      stride: int)
    #
    #     @add__init__
    #     def `SubMatrix` as NewWithSubMatrix(self, other:SubMatrix)
    #
    #     # Accessing of sub-parts of the matrix. #
    #     def Row(self, i:int) -> SubVector
    #
    #     def Range(self, row_offset:int, num_rows:int, col_offset:int,
    #               num_cols: int) -> SubMatrix
    #
    #     def RowRange(self, row_offset: int, num_rows: int) -> SubMatrix
    #
    #     def ColRange(self, col_offset: int, num_cols: int) -> SubMatrix


    class `Matrix<float>` as Matrix(MatrixBase):
      @add__init__
      def `Matrix` as new_with_size(self, r:int, c:int,
                                  resize_type:MatrixResizeType = default,
                                  stride_type:MatrixStrideType = default):
        """Create a new matrix with r rows and c columns. If the resize_type is kSetZero,
             the new data will be zero. If the resize type is kUndefined,
             the new data will be undefined. Finally if the resize type is kCopyData,
             the new data will be the same as the old data in any shared positions,
             and zero elsewhere. stride_type defines how data will be read from memory,
             we advise to let it in its default value.

          Args:
              r(int): The number of rows
              c(int): The number of columns
              resize_type(MatrixResizeType): Determines the initial values of the vector.
              stride_type(MatrixStrideType): Determines how data are read from memery.
        """

      # TODO:
      # explicit Matrix(const CuMatrixBase<OtherReal> &cu,
      #                 MatrixTransposeType trans = kNoTrans);

      def `Swap` as swap(self, other:Matrix):
        """Swaps the contents of self and other. Shallow swap."""

      # TODO:
      # void Swap(CuMatrix<Real> *mat);

      @add__init__
      def `Matrix` as new_with_matrix(self, M:MatrixBase,
                                    trans:MatrixTransposeType = default):
        """Create matrix and copy the elements M.

          Args:
              M(MatrixBase): A matrix
              trans(MatrixTransposeType): if kNoTrans(default) treat A as is,
                                          if kTrans transpose A before operation
        """

      # TODO:
      # @add__init__
      # def `Matrix` as FromSpMatrix(self, M:SpMatrix)
      # @add__init__
      # def `Matrix` as FromCompressedMatrix(self, C:CompressedMatrix)
      # @add__init__
      # def `Matrix` as FromCompressedMatrix(
      #     self, M:TpMatrix, trans:MatrixTransposeType = default)

      def `Read` as read(self, is: istream, binary: bool, add: bool = default):
        """Reads from C++ stream.

          Args:
              is(istream): The input straem.
              binary(bool): If the stream is binary.
              add(bool): True if you want to add the stream to self.
        """

      def `RemoveRow` as remove_row(self, i:int):
        """Removes a row from matrix.

          Args:
              i(int): Indexes which row will be removed. Indexing starts at 0

          Raises:
              Error if i> num_rows
        """

      def `Transpose` as transpose(self):
        """Transposes the matrix"""

      def `Resize` as resize(self, r:int, c:int,
                 resize_type:MatrixResizeType = default,
                 stride_type:MatrixStrideType = default):
        """Resizes a matrix. If the resize_type is kSetZero,
             the new data will be zero. If the resize type is kUndefined,
             the new data will be undefined. Finally if the resize type is kCopyData,
             the new data will be the same as the old data in any shared positions,
             and zero elsewhere. stride_type defines how data will be read from memory,
             we advise to let it in its default value.

          Args:
              r(int): The new number of rows
              c(int): The new number of columns
              resize_type(MatrixResizeType): Determines the initial values of the vector.
              stride_type(MatrixStrideType): Determines how data are read from memery.
        """

      # NOTE:
      # We cannot wrap Row here since SubVector is wrapped elsewhere.
      # We implement it in Python by constructing a SubVector object.
      # def Row(self, i:int) -> SubVector

      # NOTE:
      # We cannot wrap *Range here since SubMatrix is wrapped elsewhere.
      # We implement them in Python by constructing SubMatrix objects.
      # def Range(self, row_offset:int, num_rows:int, col_offset:int,
      #           num_cols: int) -> SubMatrix
      #
      # def RowRange(self, row_offset: int, num_rows: int) -> SubMatrix
      #
      # def ColRange(self, col_offset: int, num_cols: int) -> SubMatrix

    def `TraceMat` as trace_mat(A: MatrixBase) -> float:
      """Returns the trace of a matrix.

        Args:
            A(MatrixBase): A matrix

        Returns:
            The trace of A
      """

    def `TraceMatMat` as trace_mat_mat(A: MatrixBase, B: MatrixBase,
                    trans: MatrixTransposeType = default) -> float:
      """Calculates the trace of A*B

        Args:
            A(MatrixBase): A matrix
            B(MatrixBase): A matrix
            trans(MatrixTransposeType): if kNoTrans(default) treat B as is,
                                        if kTrans transpose B before operation

        Returns:
            The trace of A*B or A*B^T depending on the value of trans

        Raises:
            Error in case of dimension mismatch
      """

    def `TraceMatMatMat` as trace_mat_mat_mat(A: MatrixBase, transA: MatrixTransposeType,
                       B: MatrixBase, transB: MatrixTransposeType,
                       C: MatrixBase, transC: MatrixTransposeType) -> float:
      """Calculates the trace of A*B*C

        Args:
            A(MatrixBase): A matrix
            transA(MatrixTransposeType): if kNoTrans(default) treat B as is,
                                         if kTrans transpose A before operation
            B(MatrixBase): A matrix
            transB(MatrixTransposeType): if kNoTrans(default) treat B as is,
                                         if kTrans transpose B before operation
            C(MatrixBase): A matrix
            transC(MatrixTransposeType): if kNoTrans(default) treat C as is,
                                         if kTrans transpose C before operation

        Returns:
            The trace of A*B*C

        Raises:
            Error in case of dimension mismatch
      """

    def `TraceMatMatMatMat` as trace_mat_mat_mat_mat(
        A: MatrixBase, transA: MatrixTransposeType,
        B: MatrixBase, transB: MatrixTransposeType,
        C: MatrixBase, transC: MatrixTransposeType,
        D: MatrixBase, transD: MatrixTransposeType) -> float:
      """Calculates the trace of A*B*C*D

        Args:
            A(MatrixBase): A matrix
            transA(MatrixTransposeType): if kNoTrans(default) treat B as is,
                                         if kTrans transpose A before operation
            B(MatrixBase): A matrix
            transB(MatrixTransposeType): if kNoTrans(default) treat B as is,
                                         if kTrans transpose B before operation
            C(MatrixBase): A matrix
            transC(MatrixTransposeType): if kNoTrans(default) treat C as is,
                                         if kTrans transpose C before operation
            D(MatrixBase): A matrix
            transD(MatrixTransposeType): if kNoTrans(default) treat D as is,
                                         if kTrans transpose D before operation

        Returns:
            The trace of A*B*C

        Raises:
            Error in case of dimension mismatch
      """

    def `ApproxEqual` as approx_equal_matrix(
        A:MatrixBase, B:MatrixBase, tol:`float` as float = default) -> bool:
      """Computes the Frobenius norm of the difference of matrix A and B
           and returns True if it is less or equal than tol.

        Args:
            A(MatrixBase): A matrix
            B(MatrixBase): A matrix
            tol(float): The tolerance.

        Returns:
            True ||A-B||_F <= tol

        Raises:
            Error if size of a is different than size of b.
      """

    def `AssertEqual` as assert_equal_matrix(
        A:MatrixBase, B:MatrixBase, tol:`float` as float = default):
      """Computes the Frobenius norm of the difference of matrix A and B
           and checks if it is less or equal than tol. If the condition is
           not satisfied it will raise an error.

        Args:
            A(MatrixBase): A matrix
            B(MatrixBase): A matrix
            tol(float): The tolerance.

        Raises:
            Error if ||A-B||_F > tol
      """

    # FIXME(pavlos):
    # This needs a C++ wrapper
    # def SortSvd(s: VectorBase, U: MatrixBase, Vt: MatrixBase = default,
    #            sort_on_absolute_value: bool = default)
    #
    # def CreateEigenvalueMatrix(real:VectorBase, imag:VectorBase,
    #                           D:MatrixBase)
    #
    # FIXME(pavlos):
    # This needs a C++ wrapper
    # def AttemptComplexPower(x_re:float, x_im:float, power:float) -> bool

    def `SameDim` as same_dim_matrix(M: MatrixBase, N: MatrixBase) -> bool:
      """Checks if M and N have the same dimensions.

        Args:
            M(MatrixBase): A matrix
            N(MatrixBase): A matrix

        Returns:
            True if M.num_rows==N.num_rows && M.num_cols==N.num_cols
      """

    class `MatrixBase<double>` as DoubleMatrixBase:
      num_rows: int = property(`NumRows`)
      num_cols: int = property(`NumCols`)
      stride: int = property(`Stride`)

      def `SizeInBytes` as size_in_bytes(self) -> int:
        """Returns the number of rows"""

      # def Data(self) -> float*
      # def RowData(self) -> float*

      # FIXME(Dogan): Argument order is reversed in C++.
      # @sequential
      # def `CopyRowFromVec` as __setitem__(self, r: int,
      #                                     v: DoubleVectorBase)

      # Note (VM):
      # __getitem__ takes only two arguments (self, index), but
      # here we need three (self, row, col).
      def `operator()` as get(self, r:int, c:int) -> float:
        """Indexing operator.

          Args:
              r(int): The row
              c(int): The column

          Returns:
              The value of the indexed element
        """

      def Set(self, r:int, c:int, v:float)

      def `SetZero` as set_zero(self):
        """Set all elements to zero."""

      def `SetUnit` as set_unit(self):
        """Sets all elements to zero, and fill the diagonal with ones,
             works for non-square matrices too"""

      def `SetRandn` as set_randn(self):
        """Sets the elements to random values of a normal distribution."""

      def `SetRandUniform` as set_rand_uniform(self):
        """Sets the elements to random values of a uniform(0,1) distribution."""

      # Copy methods
      def `CopyFromMat` as copy_from_mat(self, M:DoubleMatrixBase,
                      trans:MatrixTransposeType = default):
        """Copy data from another matrix of the same size

        Args:
            M(MatrixBase): The matrix to copy from.
            trans(MatrixTransposeType): kTrans if the matrix is to be transposed
            or kNoTrans(default otherwise)

        Raises:
            Error in case of dimension mismatch
        """

      # FIXME (VM): Missing definitions
      # def `CopyFromMat` as CopyFromCudaMat(
      #     self, M:CuDoubleMatrixBase,
      #     trans:MatrixTransposeType = default)
      # def CopyFromMat(self, M:CompressedMatrix);
      # def CopyFromSp(self, M:SpDoubleMatrix);
      # def CopyFromTp(self, M:TpDoubleMatrix,
      #                trans:MatrixTransposeType = default)
      # def `CopyRowsFromVec` as CopyRowFromCudaVec(self,
      #                                             v:CuDoubleVector)

      def `CopyRowsFromVec` as copy_row_from_vec_double(self, v:DoubleVectorBase):
        """This function has two modes of operation. If v.size == rows * cols,
             then it treats the vector as a row-by-row concatenation of a matrix
             and copies to self. if v.size == cols, it sets each row of self
             to a copy of v.

        Args:
            v(VectorBase): The vector to copy from

        Raises:
            Error in case of dimension mismatch
        """

      def `CopyColsFromVec` as copy_cols_from_vec(self, v:DoubleVectorBase):
        """This function has two modes of operation. If v.size == rows * cols,
             then it treats the vector as a col-by-col concatenation of a matrix
             and copies to self. if v.size == rows, it sets each col of self
             to a copy of v.

        Args:
            v(VectorBase): The vector to copy from

        Raises:
            Error in case of dimension mismatch
        """

      def `CopyColFromVec` as copy_col_from_vec(self, v:DoubleVectorBase, col:int):
        """Copy vector into specific column of matrix.

        Args:
            v(VectorBase): The vector to copy from
            col(int): Indexes the column of the matrix. Indexing starts from 0

        Raises:
            Error in case of dimension mismatch
        """

      def `CopyRowFromVec` as copy_row_from_vec(self, v:DoubleVectorBase, row:int):
        """Copy vector into specific row of matrix.

        Args:
            v(VectorBase): The vector to copy from
            col(int): Indexes the column of the matrix. Indexing starts from 0

        Raises:
            Error in case of dimension mismatch
        """

      def `CopyDiagFromVec` as copy_diag_from_vec(self, v:DoubleVectorBase):
        """Copy vector into diagonal of matrix

        Args:
            v(VectorBase): The vector to copy from

        Raises:
            Error in case of dimension mismatch
        """

      # Accessing sub-parts of matrix #
      # Note (VM):
      # Implemented in child class DoubleMatrix

      # Special functions #

      def `Sum` as sum(self) -> float:
        """Returns sum of all elements in matrix."""

      def `Trace` as trace(self, check_square: bool = default) -> float:
        """Returns the trace of the matrix. If matrix is not square
             it will return the trace of the square matrix formed from
             the minimum dimension, e.g. if the matrix is 3x5 it will
             calculate the trace of the submatrix 3x3.

        Args:
            check_square(bool): True(default) if matrix is square

        Raises:
            Error if the matrix is not square and you have set check_square as True
        """

      def `Max` as max(self) -> float:
        """Returns maximum element of matrix."""

      def `Min` as min(self) -> float:
        """Returns minimum element of matrix."""

      def `MulElements` as mul_elements(self, A: DoubleMatrixBase):
        """Element by element multiplication with matrix A.

        Args:
            A(MatrixBase): A matrix

        Raises:
            Error in case of dimension mismatch
        """

      def `DivElements` as div_elements(self, A: DoubleMatrixBase):
        """Element by element division with matrix A,
             e.g. self(i,j) = self(i,j)/A(i,j) for all i,j.

        Args:
            A(MatrixBase): A matrix

        Raises:
            Error in case of dimension mismatch
        """

      def `Scale` as scale(self, alpha: float):
        """Scale all elements of the matrix by alpha

        Args:
            alpha(float): A scaling constant
        """
      def `Max` as max_with_mat(self, A: DoubleMatrixBase):
        """Performs the elementwise operation self(i,j) = max(self(i,j), A(i,j)) for every i,j.

        Args:
            A(MatrixBase): A matrix

        Raises:
            Error in case of dimension mismatch
        """

      def `Min` as min_with_mat(self, A: DoubleMatrixBase):
        """Performs the elementwise operation
             self(i,j) = min(self(i,j), A(i,j)) for every i,j.

        Args:
            A(MatrixBase): A matrix

        Raises:
            Error in case of dimension mismatch
        """

      def `MulColsVec` as mul_cols_vec(self, scale: DoubleVectorBase):
        """Performs self = self * diag(scale). Scales each column by
             a scalar taken from that dimension of the vector.

        Args:
            scale(VectorBase): A scaling vector

        Raises:
            Error in case of dimension mismatch
        """

      def `MulRowsVec` as mul_rows_vec(self, scale: DoubleVectorBase):
        """Performs self = diag(scale)*self. Scales each row by
             a scalar taken from that dimension of the vector.

        Args:
            scale(VectorBase): A scaling vector

        Raises:
            Error in case of dimension mismatch
        """

      def `MulRowsGroupMat` as mul_rows_group_mat(self, src: DoubleMatrixBase):
        """Divide each row of self into src.num_cols equal groups,
             and then scale i'th row's j'th group of elements by src(i, j).

        Args:
            src(MatrixBase): A scaling Matrix

        Raises:
            Error if self.num_rows != scr.num_rows || self.num_cols % src.num_cols !=0
        """

      # FIXME(Pavlos):
      # Need C++ wrappers for these functions. Moreover they do not feel like ``pythonic''
      #
      # def LogDet(self, det_sign: `float` as float = default) -> float
      #
      # def Invert(self, log_det: `float` as float = default,
      #            det_sign: `float` as float = default,
      #            inverse_needed: bool = default)
      #   """Matrix inverse
      #
      #     Args:
      #         log_det(float): Will store the log determinant
      #         det_sign(float): Will store the sign of the determinant, 1 or -1.
      #         inverse_needed(bool): If false it will return garbage. Default is true
      #
      #     Raises:
      #         Error if matrix is not square
      #   """
      #
      # def InvertDouble(self, logDet: `float` as float = default,
      #                      det_sign: `float` as float = default,
      #                      inverse_needed: bool = default)
      #   """Matrix inverse
      #
      #     Args:
      #         logDet(float): Will store the log determinant
      #         det_sign(float): Will store the sign of the determinant, 1 or -1.
      #         inverse_needed(bool): If false it will return garbage
      #
      #     Raises:
      #         Error if matrix is not square
      #   """

      def `InvertElements` as invert_elements(self):
        """Inverts all the elements of the matrix. self(i,j)=1/self(i,j)."""

      def `Transpose` as transpose(self):
        """Transposes the elements of the matrix. self(i,j)=self(j,i)."""

      # FIXME(Pavlos):
      # Indices should not be int, they are supposed to be an array
      # def CopyCols(self, src: MatrixBase, indices: int)
      # def CopyRows(self, src: MatrixBase, indices: int)
      # def AddCols(self, src: MatrixBase, indices: int)

      # FIXME:
      # void CopyRows(const Real *const *src);
      # void CopyToRows(Real *const *dst) const;
      # def AddRows(self, alpha: float, src: MatrixBase, indexes: int)

      # FIXME:
      # void AddRows(Real alpha, const Real *const *src);
      # void AddToRows(Real alpha, Real *const *dst) const;

      def `ApplyFloor` as apply_floor(self, floor_val: float):
        """Applies floor to all elements. If self(i,j)<floor then self(i,j)=floor.

        Args:
            floor(float): The floor value to check against.
        """

      def `ApplyCeiling` as apply_ceiling(self, ceiling_val: float):
        """Applies floor to all elements. If self(i,j)>ceiling then self(i,j)=ceiling.

        Args:
            ceiling(float): The ceiling value to check against.
        """

      def `ApplyLog` as apply_log(self):
        """Apply natural log to all elements."""

      def `ApplyExp` as apply_exp(self):
        """Apply exponential to each value in vector."""

      def `ApplyPow` as apply_pow(self, power: float):
        """Take all elements of matrix to a power.

        Args:
            power(float): The power which we apply to all elements of self

        Raises:
            Error if you try to handle imaginary numbers
            (e.g. square root of a negative) or in case of overflow.
        """

      def `ApplyPowAbs` as apply_pow_abs(self, power: float, include_sign: bool = default):
        """Take the absolute value of all elements of a vector to a power.
             Include the sign of the input element if include_sign == true.
             For example, if self=(-3,2) then for power=2 and include_sign=true
             we would have self=(-9,4). If power is negative and the
             input value is zero, the output is set zero.
        Args:
            power(float): The power which we apply to all alements of self
            include_sign(bool): True if we include the sign of the input element.

        Raises:
            Error if we have overflows or underflows.
        """

      def `ApplyHeaviside` as apply_heaviside(self):
        """Applies the Heaviside step function (x > 0 ? 1 : 0) to all matrix elements."""

      # FIXME(pavlos):
      # Need C++ wrappers for this
      #
      # def Eig(self, P: MatrixBase, eigs_real: VectorBase,
      #             eigs_imag: VectorBase)
      #   """Eigenvalue Decomposition of a square matrix into the form  P D P^{-1}.
      #        Be careful: the relationship of D to the eigenvalues we output is
      #        slightly complicated, due to the need for P to be real.  In the symmetric
      #        case D is diagonal and real, but in
      #        the non-symmetric case there may be complex-conjugate pairs of eigenvalues.
      #        In this case, for the equation (*this) = P D P^{-1} to hold, D must actually
      #        be block diagonal, with 2x2 blocks corresponding to any such pairs.  If a
      #        pair is lambda +- i*mu, D will have a corresponding 2x2 block
      #        [lambda, mu; -mu, lambda].
      #        Note that if the input matrix (*this) is non-invertible, P may not be invertible
      #        so in this case instead of the equation (*this) = P D P^{-1} holding, we have
      #        instead (*this) P = P D.
      #
      #     Args:
      #         P(MatrixBase): Will store the P part of PDP^{-1} decomposition
      #         eigs_real(VectorBase): Will store the real part of the eigenvalues
      #         eigs_imga(VectorBase): Will store the imaginary part of the eigenvalues
      #   """

      def `Power` as power(self, pow: float) -> bool:
        """The Power method attempts to take the matrix to a power
             (e.g P^3=P*P*P) using a method that works in general for fractional
             and negative powers. The input matrix must be invertible and have
             reasonable condition (or we don't guarantee the results. The method is
             based on the eigenvalue decomposition. It will return false and
             leave the matrix unchanged, if at entry the matrix had real negative
             eigenvalues (or if it had zero eigenvalues and the power was negative).

        Args:
            pow(float): The power which we will apply

        Returns:
            True if operation was successful
        """

      # FIXME(pavlos):
      # Need C++ wrappers for this
      #
      # def DestructiveSvd(self, s: VectorBase, U: MatrixBase,
      #                      Vt: MatrixBase)
      #   """Singular value decomposition for NONSQUARE matrices.
      #        We assume num_rows >= num_cols, and we return the "skinny" Svd,
      #        i.e. the matrix in the middle is diagonal, and the one on the left
      #        is rectangular. In Svd, self = U*diag(S)*Vt. Null pointers for U and/or
      #        Vt at input mean we do not want that output. We expect that
      #        S.dim == num_rows, U is either NULL or num_rows by num_cols,
      #        and V is either NULL or num_cols by num_cols. The singular values are
      #        not sorted (use SortSvd for that). Note that Vt is the transpose of V.
      #
      #     Args:
      #         s(VectorBase): A vector of length num_rows of self.
      #                        It must be that s.dim = self.num_cols
      #         U(MatrixBase): A Matrix of size num_rowsxnum_cols of self which
      #                        will be filled with the U part of SVD
      #         Vt(MatrixBase): A Matrix of size num_colsxnum_cols of self which
      #                         will be filled with the U part of SVD
      #
      #     Raises:
      #         Error if self.num_rows<self.num_cols, or if U is not self.num_rows
      #         by self.num_cols of self, or if Vt is not self.num_cols by self.num_cols
      #   """
      #
      # def Svd(self, s: VectorBase, U: MatrixBase, Vt: MatrixBase)
      #   """Compute SVD self = U*diag(s)*Vt. Note that the V in the call is already
      #        transposed; the normal formulation is U diag(s) V^T. Null pointers
      #        for U or V mean we don't want that output (this saves computation time).
      #        The singular values are not sorted (use SortSvd for that).
      #
      #     Args:
      #         s(VectorBase): A vector of length min(self.num_rows, self.num_cols)
      #         U(MatrixBase): A Matrix of size num_rowsxnum_cols of self which
      #                        will be filled with the U part of SVD
      #         Vt(MatrixBase): A Matrix of size num_colsxnum_cols of self which
      #                         will be filled with the U part of SVD
      #   """
      #
      # def `Svd` as SingularValues(self, s: VectorBase)
      #   """Compute SVD but only retain the singular values.
      #
      #     Args:
      #         s(VectorBase): The vector where the singular values of self will be stored.
      #                        Its length must be min(self.num_rows, self.num_cols)
      #   """

      def `MinSingularValue` as min_singular_value(self) -> float:
        """Returns the smallest singular value."""

      # FIXME(pavlos):
      # This does nothing, it's designed to trigger Valgrind errors in kaldi.
      # Probably remove altogether
      #
      # def TestUninitialized(self)

      def `Cond` as cond(self) -> float:
        """Returns the condition number of the SVD computation."""

      def `IsSymmetric` as issymmetric(self, cutoff: float = default) -> bool:
        """Returns True if the matrix is symmetric."""

      def `IsDiagonal` as isdiagonal(self, cutoff: float = default) -> bool:
        """Checks if the matrix is diagonal. The nondiagonal elements
            must be less or equal to cutoff value.

        Args:
            cutoff(float): A cutoff value. Default is 1.0e-05

        Returns:
            True if sum(digonal_elements)*cutoff > sum(nondiagonal_elements),
            otherwise false
        """

      def `IsUnit` as isunit(self, cutoff: float = default) -> bool:
        """Checks if the matrix is identity-like. It does not have to be square.
           The nondiagonal elements must be less or equal to cutoff value,
           while the diagonal ones must be one.

        Args:
            cutoff(float): A cutoff value. Default is 1.0e-05

        Returns:
            True if the diagonal elements are 1 and sum(nondiagonal_elements)<=cutoff
        """

      def `IsZero` as iszero(self, cutoff: float = default) -> bool:
        """Checks if all elements are 0 (where 0 is the cutoff value).

        Args:
            cutoff(float): A cutoff value. Default is 1.0e-05

        Returns:
            True if it is a zero matrix
        """

      def `FrobeniusNorm` as frobenius_norm(self) -> float:
        """Returns the FrobeniusNorm of the matrix"""

      def `ApproxEqual` as approx_equal(self, other: DoubleMatrixBase, tol: float = default)
          -> bool:
        """Checks if self is equal with other by calculating the Frobenius
             norm of their difference.

        Args:
            other(MatrixBase): The matrix to check against
            tol(float): the tolerance

        Returns:
            True if ||(self-other)||_F <= tol * ||self||_F
        """

      def `Equal` as equal(self, other: DoubleMatrixBase) -> bool:
        """Tests for exact equality

        Args:
            other(MatrixBase): The matrix to check against

        Returns:
            True if self(i,j)=other(i,j) for all i,j
        """

      def `LargestAbsElem` as largest_abs_elem(self) -> float:
        """Returns the largest absolute value of the matrix's elements"""

      def `LogSumExp` as log_sum_exp(self, prune: float = default) -> float:
        """Returns log(sum(exp())) without exp overflow. If prune > 0.0, it uses
             a pruning beam, discarding terms less than (max - prune).

        Args:
            prune(float): A pruning value

        Returns:
           The log(sum(exp())) where the summation is over all the
           elements of the matrix
        """

      def `ApplySoftMax` as apply_softmax(self) -> float:
        """Apply the softmax function to every element of the matrix.

          Returns:
             The normalization of the softmax, i.e. sum(exp(self(i,j)))
        """

      def `Sigmoid` as sigmoid(self, src: DoubleMatrixBase):
        """Set each element to the sigmoid of the corresponding element of src.

        Args:
            src(MatrixBase): A matrix

        Raises:
            Error in case of dimension mismatch
        """

      def `Heaviside` as heaviside(self, src: DoubleMatrixBase):
        """Set each element to the heaviside of the corresponding element of src.

        Args:
            src(MatrixBase): A matrix

        Raises:
            Error in case of dimension mismatch
        """

      def `SoftHinge` as soft_hinge(self, src: DoubleMatrixBase):
        """Set each element of self as self(i,j) = log(1 + exp(src(i,j)))

        Args:
            src(MatrixBase): A matrix

        Raises:
            Error in case of dimension mismatch
        """

      def `GroupPnorm` as group_pnorm(self, src: DoubleMatrixBase, power: float):
        """See Also:
             :kaldi:`kaldi::GroupPnorm`
        """

      # FIXME(pavlos):
      # This needs a C++ wrapper
      #
      # def GroupMaxDeriv(self, input: MatrixBase, output: MatrixBase)
      #   """See Also:
      #     :kaldi:`kaldi::GroupMaxDeriv`
      #   """

      def `Tanh` as tanh(self, src: DoubleMatrixBase):
        """Set each element to the tanh of the corresponding element of src.

        Args:
            src(MatrixBase): A matrix

        Raises:
            Error in case of dimension mismatch
        """

      # FIXME(pavlos):
      # This needs a C++ wrapper
      #
      # def DiffSigmoid(self, value: MatrixBase, diff: MatrixBase)
      #
      # def DiffTanh(self, value: MatrixBase, diff: MatrixBase)
      #
      # def SymPosSemiDefEig(self, s: VectorBase, P: MatrixBase,
      #                     check_thresh: float = default)

      def `Add` as add(self, alpha: float):
        """Add a scalar alpha to each element of the matrix.

        Args:
           alpha(float): A scalar
        """

      def `AddToDiag` as add_to_diag(self, alpha: float):
        """Add a scalar alpha to the diagonal elements of the matrix.

        Args:
           alpha(float): A scalar
        """

      def `AddVecVec` as add_vec_vec(self, alpha: float, a: DoubleVectorBase, b: DoubleVectorBase):
        """Performs the operation self = self + alpha*a*b^T

        Args:
            alpha(float): A scaling constant
            a(VectorBase): A vector
            b(VectorBase): A vector
        """

      def `AddVecToRows` as add_vec_to_rows(self, alpha: float, v: VectorBase):
        """Performs the operation self(i,:) = self(i,:)+alpha*v for all i

        Args:
            alpha(float): A scaling constant
            v(VectorBase): A vector

        Raises:
            Error in case of dimension mismatch
        """

      def `AddVecToCols` as add_vec_to_cols(self, alpha: float, v: DoubleVectorBase):
        """Performs the operation self(:,i) = self(:,i)+alpha*v for all i

        Args:
            alpha(float): A scaling constant
            v(VectorBase): A vector

        Raises:
            Error in case of dimension mismatch
        """

      def `AddMat` as add_mat(self, alpha: float, M: DoubleMatrixBase,
                 transA: MatrixTransposeType = default):
        """Performs the operation self = self+alpha*M or self = self+alpha*M^T

        Args:
            alpha(float): A scaling constant
            M(MatrixBase): A matrix
            transA(MatrixTransposeType): if kNoTrans(default) treat M as is,
                                         if kTrans transpose M before operation
        Raises:
            Error in case of dimension mismatch
        """

      def `SymAddMat2` as sym_add_mat2(self, alpha: float, M: DoubleMatrixBase,
                     transA: MatrixTransposeType, beta: float):
        """Performs the operation self = beta*self+alpha*M*M^T, for symmetric matrices.
             It only updates the lower triangle of *this. It will leave the
             matrix asymmetric; if you need it symmetric as a regular matrix,
             do CopyLowerToUpper().

        Args:
            alpha(float): A scaling constant
            M(MatrixBase): A matrix
            transA(MatrixTransposeType): if kNoTrans(default) treat M as is,
                                         if kTrans transpose M before operation
            beta(float): A scaling constant

        Raises:
            Error in case of dimension mismatch
        """

      def `AddDiagVecMat` as add_diag_vec_mat(self, alpha: float, v: DoubleVectorBase, M: DoubleMatrixBase,
                        transM: MatrixTransposeType,
                        beta: float = default):
        """Perform the operation self = beta*self+alpha*diag(v)*M

        Args:
            alpha(float): A scaling constant
            v(VectorBase): A vector
            M(MatrixBase): A matrix
            transA(MatrixTransposeType): if kNoTrans(default) treat M as is,
                                         if kTrans transpose M before operation
            beta(float): A scaling constant

        Raises:
            Error in case of dimension mismatch
        """


      def `AddMatDiagVec` as add_mat_diag_vec(self, alpha: float, M: DoubleMatrixBase,
                        transM: MatrixTransposeType, v: DoubleVectorBase,
                        beta: float = default):
        """Performs the operation self = beta*self+alpha*M*diag(v)

        Args:
            alpha(float): A scaling constant
            M(MatrixBase): A matrix
            transA(MatrixTransposeType): if kNoTrans(default) treat M as is,
                                         if kTrans transpose M before operation
            v(VectorBase): A vector
            beta(float): A scaling constant

        Raises:
            Error in case of dimension mismatch
        """

      def `AddMatMatElements` as add_mat_mat_elements(self, alpha: float, A: DoubleMatrixBase,
                            B: DoubleMatrixBase, beta: float):
        """Performs the operation self = beta*self + alpha*A.*B
             where ``.*'' is element by element multiplication.

        Args:
            alpha(float): A scaling constant
            A(MatrixBase): A matrix
            B(MatrixBase): A matrix
            beta(float): A scaling constant

        Raises:
            Error in case of dimension mismatch
        """

      # FIXME:
      # Missing SpMatrix definition
      # def AddSp(self, alpha: float, S:SpDoubleMatrix)

      def `AddMatMat` as add_mat_mat(self, alpha: float, A: DoubleMatrixBase,
                    transA: MatrixTransposeType, B: DoubleMatrixBase,
                    transB: MatrixTransposeType, beta: float):
        """Performs the operation self = beta*self+alpha*A*B.

        Args:
            alpha(float): A scaling constant
            A(MatrixBase): A matrix
            transA(MatrixTransposeType): if kNoTrans(default) treat A as is,
                                         if kTrans transpose A before operation
            B(MatrixBase): A matrix
            transB(MatrixTransposeType): if kNoTrans(default) treat B as is,
                                         if kTrans transpose B before operation
            beta(float): A scaling constant

        Raises:
            Error in case of dimension mismatch
        """

      def `SetMatMatDivMat` as set_mat_mat_div_mat(self, A: DoubleMatrixBase, B: DoubleMatrixBase,
                          C: DoubleMatrixBase):
        """Performs the operation self = A.*B./C, where ``.*'' and ``./''
             are elementwise multiplication and division. If c(i,j)==0
             then self(i,j) remains intact.

        Args:
            A(MatrixBase): A matrix
            B(MatrixBase): B matrix
            C(MatrixBase): C matrix

        Raises:
            Error in case of dimension mismatch
        """

      def `AddMatSmat` as add_mat_smat(self, alpha: float, A: DoubleMatrixBase,
                     transA: MatrixTransposeType, B: DoubleMatrixBase,
                     transB: MatrixTransposeType, beta: float):
        """A version of AddMatMat specialized for when B
             contains a lot of zeroes.

        Args:
            alpha(float): A scaling constant
            A(MatrixBase): A matrix
            transA(MatrixTransposeType): if kNoTrans(default) treat A as is,
                                         if kTrans transpose A before operation
            B(MatrixBase): A matrix
            transB(MatrixTransposeType): if kNoTrans(default) treat B as is,
                                         if kTrans transpose B before operation
            beta(float): A scaling constant

        Raises:
            Error in case of dimension mismatch
        """

      def `AddSmatMat` as add_smat_mat(self, alpha: float, A: DoubleMatrixBase,
                     transA: MatrixTransposeType, B: DoubleMatrixBase,
                     transB: MatrixTransposeType, beta: float):
        """A version of AddMatMat specialized for when A
             contains a lot of zeroes.

        Args:
            alpha(float): A scaling constant
            A(MatrixBase): A matrix
            transA(MatrixTransposeType): if kNoTrans(default) treat A as is,
                                         if kTrans transpose A before operation
            B(MatrixBase): A matrix
            transB(MatrixTransposeType): if kNoTrans(default) treat B as is,
                                         if kTrans transpose B before operation
            beta(float): A scaling constant

        Raises:
            Error in case of dimension mismatch
        """

      def `AddMatMatMat` as add_mat_mat_mat(self, alpha: float, A: DoubleMatrixBase,
                       transA: MatrixTransposeType, B: DoubleMatrixBase,
                       transB: MatrixTransposeType, C: DoubleMatrixBase,
                       transC: MatrixTransposeType, beta: float):
        """Performs the operation self = beta*self+alpha*A*B*C.

        Args:
            alpha(float): A scaling constant
            A(MatrixBase): A matrix
            transA(MatrixTransposeType): if kNoTrans(default) treat A as is,
                                         if kTrans transpose A before operation
            B(MatrixBase): A matrix
            transB(MatrixTransposeType): if kNoTrans(default) treat B as is,
                                         if kTrans transpose B before operation
            C(MatrixBase): A matrix
            transC(MatrixTransposeType): if kNoTrans(default) treat C as is,
                                         if kTrans transpose C before operation
            beta(float): A scaling constant

        Raises:
            Error in case of dimension mismatch
        """

      # FIXME:
      # Missing definitions
      # def AddSpMat(self, alpha: float, A:SpDoubleMatrix,
      #              B: DoubleMatrixBase, transB: MatrixTransposeType,
      #              beta: float)
      # def AddTpMat(self, alpha: float, A:TpDoubleMatrix,
      #              transA: MatrixTransposeType, B: DoubleMatrixBase,
      #              transB: MatrixTransposeType, beta: float)
      # def AddMatSp(self, alpha: float, A: DoubleMatrixBase,
      #              transA: MatrixTransposeType, B:SpDoubleMatrix,
      #              beta: float)
      # def AddMatTp(self, alpha: float, A: DoubleMatrixBase,
      #              transA: MatrixTransposeType, B:TpDoubleMatrix,
      #              transB: MatrixTransposeType, beta: float)
      # def AddTpTp
      # def AddSpSp

      def `CopyLowerToUpper` as copy_lower_to_upper(self):
        """Copy lower triangle to upper triangle (symmetrize).

        Raises:
            Error if matrix is not square.
        """

      def `CopyUpperToLower` as copy_upper_to_lower(self):
        """Copy upper triangle to lower triangle (symmetrize)

        Raises:
            Error if matrix is not square.
        """

      def `OrthogonalizeRows` as orthogonalize_rows(self):
        """This function orthogonalizes the rows of a matrix using
             the Gram-Schmidt process. It will use random number generation
             to fill in rows with something nonzero, in cases where the
             original matrix was of deficient row rank.

        Raises:
            Error if self.num_rows > num_cols.
        """

      def `Read` as read(self, is: istream, binary: bool, add: bool = default):
        """Reads from C++ stream.

        Args:
            is(istream): The input straem.
            binary(bool): If the stream is binary.
            add(bool): True if you want to add the stream to self.
        """

      def `Write` as write(self, os: ostream, binary: bool):
        """Writes to C++ stream.

        Args:
            os(ostream): The output straem.
            binary(bool): If the stream is binary.
        """

    class `Matrix<double>` as DoubleMatrix(DoubleMatrixBase):

      @add__init__
      def `Matrix` as new_with_size(self, r:int, c:int,
                                  resize_type:MatrixResizeType = default,
                                  stride_type:MatrixStrideType = default):
        """Create a new matrix with r rows and c columns. If the resize_type is kSetZero,
             the new data will be zero. If the resize type is kUndefined,
             the new data will be undefined. Finally if the resize type is kCopyData,
             the new data will be the same as the old data in any shared positions,
             and zero elsewhere. stride_type defines how data will be read from memory,
             we advise to let it in its default value.

        Args:
            r(int): The number of rows
            c(int): The number of columns
            resize_type(MatrixResizeType): Determines the initial values of the vector.
            stride_type(MatrixStrideType): Determines how data are read from memery.
        """

      # TODO:
      # explicit Matrix(const CuMatrixBase<OtherReal> &cu,
      #                 MatrixTransposeType trans = kNoTrans);

      def `Swap` as swap(self, other: DoubleMatrix):
        """Swaps the contents of self and other. Shallow swap."""

      # TODO:
      # void Swap(CuMatrix<Real> *mat);

      @add__init__
      def `Matrix` as new_with_matrix(self, M:MatrixBase,
                                    trans:MatrixTransposeType = default):
        """Create matrix and copy the elements M.

        Args:
            M(MatrixBase): A matrix
            trans(MatrixTransposeType): if kNoTrans(default) treat A as is,
                                        if kTrans transpose A before operation
        """

      # TODO:
      # @add__init__
      # def `Matrix` as FromCompressedMatrix(self, C:CompressedMatrix)
      # @add__init__
      # def `Matrix` as FromSpDoubleMatrix(self, M:SpDoubleMatrix)
      # @add__init__
      # def `Matrix` as FromTpMatrix(self, M:TpDoubleMatrix,
      #                              trans:MatrixTransposeType = default)

      def `Read` as read(self, is: istream, binary: bool, add: bool = default):
        """Reads from C++ stream.

        Args:
            is(istream): The input straem.
            binary(bool): If the stream is binary.
            add(bool): True if you want to add the stream to self.
        """

      def `RemoveRow` as remove_row(self, i:int):
        """Removes a row from matrix.

        Args:
            i(int): Indexes which row will be removed. Indexing starts at 0

        Raises:
            Error if i> num_rows
        """

      def `Transpose` as transpose(self):
        """Transposes the matrix"""

      def `Resize` as resize(self, r:int, c:int,
                 resize_type:MatrixResizeType = default,
                 stride_type:MatrixStrideType = default):
        """Resizes a matrix. If the resize_type is kSetZero,
             the new data will be zero. If the resize type is kUndefined,
             the new data will be undefined. Finally if the resize type is kCopyData,
             the new data will be the same as the old data in any shared positions,
             and zero elsewhere. stride_type defines how data will be read from memory,
             we advise to let it in its default value.

        Args:
            r(int): The new number of rows
            c(int): The new number of columns
            resize_type(MatrixResizeType): Determines the initial values of the vector.
            stride_type(MatrixStrideType): Determines how data are read from memery.
        """

      # NOTE:
      # We cannot wrap Row here since SubVector is wrapped elsewhere.
      # We implement it in Python by constructing a SubVector object.
      # def Row(self, i:int) -> SubVector

      # NOTE:
      # We cannot wrap *Range here since SubMatrix is wrapped elsewhere.
      # We implement them in Python by constructing SubMatrix objects.
      # def Range(self, row_offset:int, num_rows:int, col_offset:int,
      #           num_cols: int) -> SubMatrix
      #
      # def RowRange(self, row_offset: int, num_rows: int) -> SubMatrix
      #
      # def ColRange(self, col_offset: int, num_cols: int) -> SubMatrix

    def `TraceMat` as trace_double_mat(A: DoubleMatrixBase) -> float:
      """Returns the trace of a matrix.

      Args:
          A(MatrixBase): A matrix

      Returns:
          The trace of A
      """

    def `TraceMatMat` as trace_double_mat_mat(
        A: DoubleMatrixBase, B: DoubleMatrixBase,
        trans:MatrixTransposeType = default) -> float:
      """Calculates the trace of A*B

      Args:
          A(MatrixBase): A matrix
          B(MatrixBase): A matrix
          trans(MatrixTransposeType): if kNoTrans(default) treat B as is,
                                      if kTrans transpose B before operation

      Returns:
          The trace of A*B or A*B^T depending on the value of trans

      Raises:
          Error in case of dimension mismatch
      """

    def `TraceMatMatMat` as trace_double_mat_mat_mat(
        A: DoubleMatrixBase, transA: MatrixTransposeType,
        B: DoubleMatrixBase, transB: MatrixTransposeType,
        C: DoubleMatrixBase, transC: MatrixTransposeType) -> float:
      """Calculates the trace of A*B*C

      Args:
          A(MatrixBase): A matrix
          transA(MatrixTransposeType): if kNoTrans(default) treat B as is,
                                       if kTrans transpose A before operation
          B(MatrixBase): A matrix
          transB(MatrixTransposeType): if kNoTrans(default) treat B as is,
                                       if kTrans transpose B before operation
          C(MatrixBase): A matrix
          transC(MatrixTransposeType): if kNoTrans(default) treat C as is,
                                       if kTrans transpose C before operation

      Returns:
          The trace of A*B*C

      Raises:
          Error in case of dimension mismatch
      """

    def `TraceMatMatMatMat` as trace_double_mat_mat_mat_mat(
        A: DoubleMatrixBase, transA: MatrixTransposeType,
        B: DoubleMatrixBase, transB: MatrixTransposeType,
        C: DoubleMatrixBase, transC: MatrixTransposeType,
        D: DoubleMatrixBase, transD: MatrixTransposeType) -> float:
      """Calculates the trace of A*B*C*D

      Args:
          A(MatrixBase): A matrix
          transA(MatrixTransposeType): if kNoTrans(default) treat B as is,
                                       if kTrans transpose A before operation
          B(MatrixBase): A matrix
          transB(MatrixTransposeType): if kNoTrans(default) treat B as is,
                                       if kTrans transpose B before operation
          C(MatrixBase): A matrix
          transC(MatrixTransposeType): if kNoTrans(default) treat C as is,
                                       if kTrans transpose C before operation
          D(MatrixBase): A matrix
          transD(MatrixTransposeType): if kNoTrans(default) treat D as is,
                                       if kTrans transpose D before operation

      Returns:
          The trace of A*B*C

      Raises:
          Error in case of dimension mismatch
      """

    def `ApproxEqual` as approx_equal_double_matrix(
        A:DoubleMatrixBase, B:DoubleMatrixBase,
        tol:`double` as float = default) -> bool:
      """Computes the Frobenius norm of the difference of matrix A and B
           and returns True if it is less or equal than tol.

      Args:
          A(MatrixBase): A matrix
          B(MatrixBase): A matrix
          tol(float): The tolerance.

      Returns:
          True ||A-B||_F <= tol

      Raises:
          Error if size of a is different than size of b.
      """

    def `AssertEqual` as assert_equal_double_matrix(
        A:DoubleMatrixBase, B:DoubleMatrixBase,
        tol:`double` as float = default):
      """Computes the Frobenius norm of the difference of matrix A and B
           and checks if it is less or equal than tol. If the condition is
           not satisfied it will raise an error.

      Args:
          A(MatrixBase): A matrix
          B(MatrixBase): A matrix
          tol(float): The tolerance.

      Raises:
          Error if ||A-B||_F > tol
      """

    # FIXME(pavlos):
    # This needs a C++ wrapper
    #
    # def `SortSvd` as SortDoubleSvd(
    #     s: DoubleVectorBase, U: DoubleMatrixBase,
    #     Vt: DoubleMatrixBase = default,
    #     sort_on_absolute_value: bool = default)
    #
    # def `CreateEigenvalueMatrix` as CreateEigenvalueDoubleMatrix(
    #     real:DoubleVectorBase, imag:DoubleVectorBase, D:DoubleMatrixBase)

    def `SameDim` as same_dim_double_matrix(M: DoubleMatrixBase,
                                         N: DoubleMatrixBase) -> bool:
      """Checks if M and N have the same dimensions.

      Args:
          M(MatrixBase): A matrix
          N(MatrixBase): A matrix

      Returns:
          True if M.num_rows==N.num_rows && M.num_cols==N.num_cols
      """

    class HtkHeader:
        mNSamples: int
        mSamplePeriod: int
        mSampleSize: int
        mSampleKind: int

    def `ReadHtk` as read_htk(is: istream, M: Matrix, header: HtkHeader) -> bool

    def `WriteHtk` as wrie_htk(os: ostream , M: MatrixBase, header: HtkHeader) -> bool

    def `WriteSphinx` as wrie_sphinx(os: ostream, M: MatrixBase) -> bool
