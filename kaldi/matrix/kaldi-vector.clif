from "matrix/matrix-common_clifwrap.h" import *

from "matrix/kaldi-vector.h":
  namespace `kaldi`:
    class `VectorBase<float>` as VectorBase:
      def SetZero(self)

      def IsZero(self, cutoff: float = default) -> bool

      def Set(self, f: float)

      def SetRandn(self)

      def SetRandUniform(self)

      def RandCategorical(self) -> int

      def `Dim` as __len__(self) -> int

      def SizeInBytes(self) -> int

      # NOTE(Dogan):
      # It is probably a bad idea to expose the Data method in Python since its
      # return value is a pointer to the underlying data array which can easily
      # become dangling as C++ object lifetime is different from Python object
      # lifetime. Also, CLIF does not support C arrays (or raw pointers to C
      # arrays), hence we cannot automatically generate a wrapper for it. One
      # option is to add another method to the C++ API wrapping the data array
      # with a shared pointer. Another option is to write the wrapper manually.
      #
      # def Data(self) -> float

      @sequential
      def `operator()` as __getitem__(self, i: int) -> float

      @sequential
      def `Set` as __setitem__(self, i: int, v: float)

      # NOTE(Dogan):
      # We cannot wrap this here since SubVector is not defined yet.
      # def Range(self, o: int, l: int) -> SubVector

      def CopyFromVec(self, v: VectorBase)

      # NOTE(Dogan):
      # We cannot wrap this here since PackedMatrix is not defined yet.
      # def CopyFromPacked(self, M: PackedMatrix)

      def ApplyLog(self)

      def ApplyLogAndCopy(self, v: VectorBase)

      def ApplyExp(self)

      def ApplyAbs(self)

      def ApplyFloor(self, floor: float) -> int

      def ApplyCeiling(self, ceiling: float) -> int

      def `ApplyFloor` as ApplyFloorVector(self, floor: VectorBase) -> int

      def ApplySoftMax(self) -> float

      def ApplyLogSoftMax(self) -> float

      def Tanh(self, src: VectorBase)

      def Sigmoid(self, src: VectorBase)

      def ApplyPow(self, power: float)

      def ApplyPowAbs(self, power: float, include_sign: bool = default)

      def Norm(self, p: float) -> float

      def ApproxEqual(self, other: VectorBase, tol: float = default) -> bool

      def InvertElements(self)

      def AddVec(self, alpha: float, v: VectorBase)

      def AddVec2(self, alpha: float, v: VectorBase)

      # NOTE(Dogan):
      # We cannot wrap this here since MatrixBase is not defined yet.
      # def AddMatVec(self, alpha: `float` as float, M: MatrixBase,
      #               trans: MatrixTransposeType, v: VectorBase,
      #               beta: `float` as float)

      # NOTE(Dogan):
      # We cannot wrap this here since MatrixBase is not defined yet.
      # def AddMatSvec(self, alpha: `float` as float, M: MatrixBase,
      #                trans: MatrixTransposeType, v: VectorBase,
      #                beta: `float` as float)

      # NOTE(Dogan):
      # We cannot wrap this here since SpMatrix is not defined yet.
      # def AddSpVec(self, alpha: `float` as float, M: SpMatrix,
      #              v: VectorBase, beta: `float` as float)

      # NOTE(Dogan):
      # We cannot wrap this here since TpMatrix is not defined yet.
      # def AddTpVec(self, alpha: `float` as float, M: TpMatrix,
      #              trans: MatrixTransposeType, v: VectorBase,
      #              beta: `float` as float)

      def ReplaceValue(self, orig: float, changed: float)

      def MulElements(self, v: VectorBase)

      def DivElements(self, v: VectorBase)

      def Add(self, c: float)

      def AddVecVec(self, alpha: float, v: VectorBase,
                    r: VectorBase, beta: float)

      def AddVecDivVec(self, alpha: float, v: VectorBase,
                       r: VectorBase, beta: float)

      def Scale(self, alpha: float)

      # NOTE(Dogan):
      # We cannot wrap this here since TpMatrix is not defined yet.
      # def MulTp(self, M: TpMatrix, trans: MatrixTransposeType)

      # NOTE(Dogan):
      # We cannot wrap this here since TpMatrix is not defined yet.
      # def Solve(self, M: TpMatrix, trans: MatrixTransposeType)

      # NOTE(Dogan):
      # We cannot wrap this here since MatrixBase is not defined yet.
      # def CopyRowsFromMat(self, M: MatrixBase)

      # NOTE(Dogan):
      # We cannot wrap this here since MatrixBase is not defined yet.
      # def CopyColsFromMat(self, M: MatrixBase)

      # NOTE(Dogan):
      # We cannot wrap this here since MatrixBase is not defined yet.
      # def CopyRowFromMat(self, M: MatrixBase, row: int)

      # NOTE(Dogan):
      # We cannot wrap this here since MatrixBase is not defined yet.
      # def CopyColFromMat(self, M: MatrixBase, col: int)

      # NOTE(Dogan):
      # We cannot wrap this here since MatrixBase is not defined yet.
      # def CopyDiagFromMat(self, M: MatrixBase)

      # NOTE(Dogan):
      # We cannot wrap this here since PackedMatrix is not defined yet.
      # def CopyDiagFromPacked(self, M: PackedMatrix)

      # NOTE(Dogan):
      # We cannot wrap this here since SpMatrix is not defined yet.
      # def CopyDiagFromSp(self, M: SpMatrix)

      # NOTE(Dogan):
      # We cannot wrap this here since TpMatrix is not defined yet.
      # def CopyDiagFromTp(self, M: TpMatrix)

      def Max(self) -> float

      def `Max` as MaxIndex(self, index: int) -> float

      def Min(self) -> float

      def `Min` as MinIndex(self, index: int) -> float

      def Sum(self) -> float

      def SumLog(self) -> float

      def LogSumExp(self, prune: float = default) -> float

      # NOTE(Dogan):
      # We cannot wrap this here since MatrixBase is not defined yet.
      # def AddRowSumMat(self, alpha: `float` as float, M: MatrixBase,
      #                  beta: `float` as float = default)

      # NOTE(Dogan):
      # We cannot wrap this here since MatrixBase is not defined yet.
      # def AddColSumMat(self, alpha: `float` as float, M: MatrixBase,
      #                  beta: `float` as float = default)

      # NOTE(Dogan):
      # We cannot wrap this here since MatrixBase is not defined yet.
      # def AddDiagMat2(self, alpha: `float` as float, M: MatrixBase,
      #                 trans: MatrixTransposeType = default,
      #                 beta: `float` as float = default)

      # NOTE(Dogan):
      # We cannot wrap this here since MatrixBase is not defined yet.
      # def AddDiagMatMat(self, alpha: `float` as float,
      #                   M: MatrixBase, transM: MatrixTransposeType,
      #                   N: MatrixBase, transN: MatrixTransposeType,
      #                   beta: `float` as float = default)

      # TODO(Dogan): Wrap istream.
      # def Read(in: istream, binary: bool, add: bool = false);

      # TODO(Dogan): Wrap ostream.
      # def Write(in: ostream, binary: bool);

    class `SubVector<float>` as SubVector(VectorBase):
      @add__init__
      def `SubVector` as New(self, t: VectorBase, origin: int, length: int)

      @add__init__
      def `SubVector` as Copy(self, other: SubVector)

      # NOTE(Dogan):
      # We cannot wrap this here since PackedMatrix is not defined yet.
      # @add__init__
      # def `SubVector` as CopyFromPackedMatrix(self, M: PackedMatrix)

      # NOTE(Dogan):
      # We cannot wrap this here since MatrixBase is not defined yet.
      # @add__init__
      # def `SubVector` as CopyFromMatrixRow(self, M: MatrixBase, row: int)

      def Range(self, o: int, l: int) -> SubVector


    class `Vector<float>` as Vector(VectorBase):
      @add__init__
      def `Vector` as New(self, s: int,
                          resize_type: MatrixResizeType = default)

      # NOTE(Dogan):
      # Match fails since this signature matches both copy constructors.
      # @add__init__
      # def `Vector` as CopyFromVector(self, v: Vector)

      @add__init__
      def `Vector` as Copy(self, v: VectorBase)

      def Swap(self, other: Vector)

      # TODO(Dogan): Wrap istream.
      # def Read(in: istream, binary: bool, add: bool = false);

      def Range(self, o: int, l: int) -> SubVector

      def Resize(self, length: int,
                 resize_type: MatrixResizeType = default)

      # NOTE: Since CLIF combines setitem and delitem into a single wrapper,
      # we need to expose setitem in Vector as well. Otherwise setitem raises
      # NotImplementedError at runtime. This is probably a bug in CLIF.
      @sequential
      def `Set` as __setitem__(self, i: int, v: float)

      @sequential
      def `RemoveElement` as __delitem__(self, i: int)

    # TODO(Dogan): Wrap iostream and look into wrapping stream ops in Python.
    # def `operator<<` as Write(out: ostream, v: VectorBase) -> ostream
    # def `operator>>` as Write(in: istream, v: VectorBase) -> istream
    # def `operator>>` as Write(in: istream, v: Vector) -> istream

    # NOTE(Dogan): Explicit mention of compatible type `float` is needed for
    # template deduction. CLIF defaults to `double` for Python float.
    def ApproxEqual(a: VectorBase, b: VectorBase,
                    tol: `float` as float = default) -> bool

    def AssertEqual(a: VectorBase, b: VectorBase,
                    tol: `float` as float = default)

    def VecVec(v1: VectorBase, v2: VectorBase) -> float

    # NOTE(Dogan):
    # We cannot wrap this here since MatrixBase is not defined yet.
    # def VecMatVec(v1: VectorBase, M: MatrixBase, v2: VectorBase) -> float
