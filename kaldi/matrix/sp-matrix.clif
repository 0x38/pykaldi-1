from "matrix/matrix-common-clifwrap.h" import *
from "matrix/kaldi-vector-clifwrap.h" import *
from "matrix/kaldi-matrix-clifwrap.h" import *
from "matrix/packed-matrix-clifwrap.h" import *
from "matrix/matrix-ext.h" import *

from "matrix/sp-matrix.h":
  namespace `kaldi`:
    class `SpMatrix<float>` as SpMatrix(PackedMatrix):

      @add__init__
      def `SpMatrix` as new(self, r: int,
                            resize_type: MatrixResizeType = default)

      @add__init__
      def `SpMatrix` as new_with_other(self, orig:SpMatrix)

      @add__init__
      def `SpMatrix` as new_with_matrix(self, orig: MatrixBase,
                                      copy_type: SpCopyType = default)

      def `Swap` as swap(self, other: SpMatrix)

      def `Resize` as resize(self, nRows: int, resize_type:MatrixResizeType = default)

      def `CopyFromSp` as copy_from_sp(self, other:SpMatrix)

      def `CopyFromMat` as copy_from_mat(self, orig:MatrixBase, copy_type:SpCopyType = default)

      def `operator()` as get(self, r: int, c: int) -> float:
        """Indexing operator.

        Args:
            r(int): The row. Indexing starts from 0
            c(int): The column. Indexing starts from 0

        Returns:
            The value of the indexed element
        """

      def `Invert` as invert(self):
        """Invert the matrix."""

      def `InvertDouble` as invert_double(self)

      def `Cond` as cond(self) -> float:
        """Returns the condition number of the SVD computation."""

      def `ApplyPow` as apply_pow(self, exponent: float)

      def `SymPosSemiDefEig` as sym_pos_semi_def_eig(self, s: VectorBase, P:MatrixBase,
                           tolerance:float = default)

      def `Eig` as eig(self, s: VectorBase, P: MatrixBase = default)

      def `TopEigs` as top_eigs(self, s: VectorBase, P: MatrixBase,
                  lanczos_dim: int = default)

      def `Log` as log(self)

      def `Exp` as exp(self)

      def `MaxAbsEig` as max_abs_eig(self) -> float

      # TODO: Implement in Python
      # def PrintEigs(self, name:str)

      def `IsPosDef` as isposdef(self) -> bool

      def `AddSp` as add_sp(self, alpha:float, Ma:SpMatrix)

      def `LogPosDefDet` as log_pos_def_det(self) -> float

      # TODO: Implement C++ wrapper
      # def LogDet(self) -> (logdet: float, det_sign: float)

      def `AddVec2` as add_vec2(self, alpha: float, v: VectorBase)

      def `AddVecVec` as add_vec_vec(self, alpha: float, v: VectorBase, w:VectorBase)

      def `AddVec2Sp` as add_vec_2_sp(self, alpha: float, v: VectorBase, S:SpMatrix, beta: float)

      def `AddDiagVec` as add_diag_vec(self, alpha: float, v:VectorBase)

      def `AddMat2` as add_mat2(self, alpha: float, M: MatrixBase,
                  transM: MatrixTransposeType, beta: float)

      def `AddMat2Sp` as add_mat_2_sp(self, alpha: float, M: MatrixBase,
                    transM: MatrixTransposeType, A:SpMatrix,
                    beta: float = default)

      def `AddSmat2Sp` as add_smat_2_sp(self, alpha: float, M:MatrixBase,
                     transM:MatrixTransposeType, A:SpMatrix,
                     beta: float = default)

      # FIXME in sp-matrix-ext.h
      # def AddTp2Sp(self, alpha:float, T:TpMatrix,
      #              transM: MatrixTransposeType, A:SpMatrix,
      #              beta: float = default)
      # def AddTp2(self, alpha: float, T:TpMatrix,
      #            transM: MatrixTransposeType, beta:float = default)

      def `AddMat2Vec` as add_mat_2_vec(self, alpha:float, M:MatrixBase,
                     transM:MatrixTransposeType, v:VectorBase,
                     beta: float = default)

      def `ApplyFloor` as apply_floor_matrix(self, floor:SpMatrix,
                                           alpha: float = default,
                                           verbose: bool = default) -> int

      def `ApplyFloor` as apply_floor(self, floor:float) -> int

      def `IsDiagonal` as isdiagonal(self, cutoff:float = default) -> bool

      def `IsUnit` as isunit(self, cutoff:float = default) -> bool

      def `IsZero` as iszero(self, cutoff:float = default) -> bool

      def `IsTridiagonal` as istriagonal(self, cutoff:float = default) -> bool

      def `FrobeniusNorm` as frobenius_norm(self) -> float

      def `ApproxEqual` as approx_equal(self, other:SpMatrix, tol:float = default) -> bool

      def `LimitCond` as limit_cond(self, maxCond: float = default,
                    invert:bool = default) -> int

      def `LimitCondDouble` as limit_cond_double(self, maxCond: float = default,
                          invert: bool = default) -> int

      def `Trace` as trace(self) -> float

      def `Tridiagonalize` as triagonalize(self, Q:MatrixBase)

      def `Qr` as qr(self, Q:MatrixBase)


    class `SpMatrix<double>` as DoubleSpMatrix(PackedMatrix):

      @add__init__
      def `SpMatrix` as New(self, r: int,
                            resize_type: MatrixResizeType = default)

      @add__init__
      def `SpMatrix` as new_with_other_sp(self, orig:DoubleSpMatrix)

      @add__init__
      def `SpMatrix` as new_with_matrix(self, orig: DoubleMatrixBase,
                                      copy_type: SpCopyType = default)

      def `Swap` as swap_with_other(self, other: DoubleSpMatrix)

      def `Resize` as resize(self, nRows: int, resize_type: MatrixResizeType = default)

      def `CopyFromSp` as copy_from_sp(self, other: DoubleSpMatrix)

      def `CopyFromMat` as copy_from_mat(self, orig: DoubleMatrixBase,
                      copy_type: SpCopyType = default)

      def `operator()` as get(self, r: int, c: int) -> float

      def `Invert` as invert(self)

      def `InvertDouble` as invert_double(self)

      def `Cond` as cond(self) -> float

      def `ApplyPow` as apply_pow(self, exponent: float)

      def `SymPosSemiDefEig` as sym_pos_semi_def_eig(self, s: DoubleVectorBase, P:DoubleMatrixBase,
                           tolerance:float = default)

      def `Eig` as eig(self, s: DoubleVectorBase, P: DoubleMatrixBase = default)

      def `TopEigs` as top_eigs(self, s: DoubleVectorBase, P: DoubleMatrixBase,
                  lanczos_dim: int = default)

      def `Log` as log(self)

      def `Exp` as exp(self)

      def `MaxAbsEig` as max_abs_eig(self) -> float

      # TODO: Implement in Python
      # def PrintEigs(self, name:str)

      def `IsPosDef` as isposdef(self) -> bool

      def `AddSp` as add_sp(self, alpha:float, Ma:DoubleSpMatrix)

      def `LogPosDefDet` as log_pos_def_det(self) -> float

      # TODO: Implement C++ wrapper
      # def LogDet(self) -> (logdet: float, det_sign: float)

      def `AddVec2` as add_vec2(self, alpha: float, v: DoubleVectorBase)

      def `AddVecVec` as add_vec_vec(self, alpha: float, v: DoubleVectorBase,
                    w:DoubleVectorBase)

      def `AddVec2Sp` as add_vec_2_sp(self, alpha: float, v: DoubleVectorBase,
                    S:DoubleSpMatrix, beta: float)

      def `AddDiagVec` as add_diag_vec(self, alpha: float, v:DoubleVectorBase)

      def `AddMat2` as add_mat2(self, alpha: float, M: DoubleMatrixBase,
                  transM: MatrixTransposeType, beta: float)

      def `AddMat2Sp` as add_mat_2_sp(self, alpha: float, M: DoubleMatrixBase,
                    transM: MatrixTransposeType, A:DoubleSpMatrix,
                    beta: float = default)

      def `AddSmat2Sp` as add_smat_2_sp(self, alpha: float, M:DoubleMatrixBase,
                     transM:MatrixTransposeType, A:DoubleSpMatrix,
                     beta: float = default)

      # FIXME in sp-matrix-ext.h
      # def AddTp2Sp(self, alpha:float, T:TpMatrix,
      #              transM: MatrixTransposeType, A:SpMatrix,
      #              beta: float = default)
      # def AddTp2(self, alpha: float, T:TpMatrix,
      #            transM: MatrixTransposeType, beta:float = default)

      def `AddMat2Vec` as add_mat_2_vec(self, alpha:float, M:DoubleMatrixBase,
                     transM:MatrixTransposeType, v:DoubleVectorBase,
                     beta: float = default)

      def `ApplyFloor` as apply_floor(self, Floor:DoubleSpMatrix,
                                     alpha: float = default,
                                     verbose: bool = default) -> int

      def `ApplyFloor` as floor(self, floor:float) -> int

      def `IsDiagonal` as isdiagonal(self, cutoff:float = default) -> bool

      def `IsUnit` as isunit(self, cutoff:float = default) -> bool

      def `IsZero` as iszero(self, cutoff:float = default) -> bool

      def `IsTridiagonal` as istriagonal(self, cutoff:float = default) -> bool

      def `FrobeniusNorm` as frobenius_norm(self) -> float

      def `ApproxEqual` as approx_equal(self, other:DoubleSpMatrix,
                      tol:float = default) -> bool

      def `LimitCond` as limit_cond(self, maxCond: float = default,
                    invert:bool = default) -> int

      def `LimitCondDouble` as limit_cond_double(self, maxCond: float = default,
                          invert: bool = default) -> int

      def `Trace` as trace(self) -> float

      def `Tridiagonalize` as triagonalize(self, Q:DoubleMatrixBase)

      def `Qr` as qr(self, Q:DoubleMatrixBase)


    def `TraceSpSp` as trace_sp_sp(A:SpMatrix, B:SpMatrix) -> float

    def `TraceSpSp` as trace_double_sp_sp(A:DoubleSpMatrix,
                                       B:DoubleSpMatrix) -> float

    def `ApproxEqual` as approx_equal_sp_matrix(
        A:SpMatrix, B:SpMatrix, tol:`float` as float = default) -> bool

    def `AssertEqual` as assert_equal_sp_matrix(A:SpMatrix, B:SpMatrix,
                                             tol:`float` as float = default)

    def `TraceSpSpLower` as trace_sp_sp_lower(A:SpMatrix, B:SpMatrix) -> float

    def `TraceSpMat` as trace_sp_mat(A:SpMatrix, B:MatrixBase) -> float

    def `TraceMatSpMat` as trace_mat_sp_mat(A:MatrixBase, transA:MatrixTransposeType, B:SpMatrix,
                      C:MatrixBase, transC: MatrixTransposeType) -> float

    def `TraceMatSpMatSp` as trace_mat_sp_mat_sp(A:MatrixBase, transA:MatrixTransposeType,
                        B:SpMatrix, C:MatrixBase,
                        transC: MatrixTransposeType, D:SpMatrix) -> float

    def `VecSpVec` as vec_sp_vec(v1:VectorBase, M:SpMatrix, v2:VectorBase) -> float

    class SolverOptions:
      K:float
      eps:float
      name:str
      optimize_delta:bool
      diagonal_precondition:bool
      print_debug_output:bool

      @add__init__
      def `SolverOptions` as solver_options_with_name(self, name:str)

      def `Check` as check(self)

    def `SolveQuadraticProblem` as solve_quadratic_problem(H:SpMatrix, g:VectorBase, opts:SolverOptions,
                              x:VectorBase) -> float

    def `SolveQuadraticMatrixProblem` as solve_quadratic_matrix_problem(Q:SpMatrix, Y:MatrixBase, P:SpMatrix,
                                    opts:SolverOptions, M:MatrixBase) -> float

    def `SolveDoubleQuadraticMatrixProblem` as solve_double_quadratic_matrix_problem(
        G:MatrixBase, P1:SpMatrix, P2:SpMatrix, Q1:SpMatrix, Q2:SpMatrix,
        opts:SolverOptions, M:MatrixBase) -> float
