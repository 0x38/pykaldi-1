from "matrix/matrix-common-clifwrap.h" import *

from "matrix/kaldi-vector.h":
  namespace `kaldi`:
    class `VectorBase<float>` as VectorBase:
      def SetZero(self)

      def IsZero(self, cutoff: float = default) -> bool

      def `Set` as fill_(self, f: float)

      def SetRandn(self)

      def SetRandUniform(self)

      def RandCategorical(self) -> int

      def `Dim` as __len__(self) -> int

      def `Dim` as size(self) -> int

      def `SizeInBytes` as size_in_bytes(self) -> int

      # NOTE:
      # It is probably a bad idea to expose the Data method in Python since its
      # return value is a pointer to the underlying data array which can easily
      # become dangling as C++ object lifetime is different from Python object
      # lifetime. Also, CLIF does not support C arrays (or raw pointers to C
      # arrays), hence we cannot automatically generate a wrapper for it. One
      # option is to add another method to the C++ API wrapping the data array
      # with a shared pointer. Another option is to write the wrapper manually.
      #
      # def Data(self) -> float

      @sequential
      def `operator()` as __getitem__(self, index: int) -> float

      @sequential
      def `Set` as __setitem__(self, index: int, value: float)

      # NOTE:
      # We cannot wrap this here since SubVector is not defined yet.
      # def Range(self, o: int, l: int) -> SubVector

      def CopyFromVec(self, v: VectorBase)

      # NOTE:
      # We cannot wrap this here since PackedMatrix is not defined yet.
      # def CopyFromPacked(self, M: PackedMatrix)

      def ApplyLog(self)

      def ApplyLogAndCopy(self, v: VectorBase)

      def ApplyExp(self)

      def ApplyAbs(self)

      def `ApplyFloor` as floor_(self, floor: float) -> int

      def ApplyCeiling(self, ceiling: float) -> int

      def `ApplyFloor` as ApplyFloorVector(self,
                                           floor_vector: VectorBase) -> int

      def ApplySoftMax(self) -> float

      def ApplyLogSoftMax(self) -> float

      def Tanh(self, src: VectorBase)

      def Sigmoid(self, src: VectorBase)

      def ApplyPow(self, power: float)

      def ApplyPowAbs(self, power: float, include_sign: bool = default)

      def Norm(self, p: float) -> float

      def ApproxEqual(self, other: VectorBase, tol: float = default) -> bool

      def InvertElements(self)

      def AddVec(self, alpha: float, v: VectorBase)

      def AddVec2(self, alpha: float, v: VectorBase)

      # NOTE:
      # We cannot wrap this here since MatrixBase is not defined yet.
      # def AddMatVec(self, alpha: `float` as float, M: MatrixBase,
      #               trans: MatrixTransposeType, v: VectorBase,
      #               beta: `float` as float)

      # NOTE:
      # We cannot wrap this here since MatrixBase is not defined yet.
      # def AddMatSvec(self, alpha: `float` as float, M: MatrixBase,
      #                trans: MatrixTransposeType, v: VectorBase,
      #                beta: `float` as float)

      # NOTE:
      # We cannot wrap this here since SpMatrix is not defined yet.
      # def AddSpVec(self, alpha: `float` as float, M: SpMatrix,
      #              v: VectorBase, beta: `float` as float)

      # NOTE:
      # We cannot wrap this here since TpMatrix is not defined yet.
      # def AddTpVec(self, alpha: `float` as float, M: TpMatrix,
      #              trans: MatrixTransposeType, v: VectorBase,
      #              beta: `float` as float)

      def ReplaceValue(self, orig: float, changed: float)

      def MulElements(self, v: VectorBase)

      def DivElements(self, v: VectorBase)

      def Add(self, constant: float)

      def AddVecVec(self, alpha: float, v: VectorBase,
                    r: VectorBase, beta: float)

      def AddVecDivVec(self, alpha: float, v: VectorBase,
                       r: VectorBase, beta: float)

      def Scale(self, alpha: float)

      # NOTE:
      # We cannot wrap this here since TpMatrix is not defined yet.
      # def MulTp(self, M: TpMatrix, trans: MatrixTransposeType)

      # NOTE:
      # We cannot wrap this here since TpMatrix is not defined yet.
      # def Solve(self, M: TpMatrix, trans: MatrixTransposeType)

      # NOTE:
      # We cannot wrap this here since MatrixBase is not defined yet.
      # def CopyRowsFromMat(self, M: MatrixBase)

      # NOTE:
      # We cannot wrap this here since MatrixBase is not defined yet.
      # def CopyColsFromMat(self, M: MatrixBase)

      # NOTE:
      # We cannot wrap this here since MatrixBase is not defined yet.
      # def CopyRowFromMat(self, M: MatrixBase, row: int)

      # NOTE:
      # We cannot wrap this here since MatrixBase is not defined yet.
      # def CopyColFromMat(self, M: MatrixBase, col: int)

      # NOTE:
      # We cannot wrap this here since MatrixBase is not defined yet.
      # def CopyDiagFromMat(self, M: MatrixBase)

      # NOTE:
      # We cannot wrap this here since PackedMatrix is not defined yet.
      # def CopyDiagFromPacked(self, M: PackedMatrix)

      # NOTE:
      # We cannot wrap this here since SpMatrix is not defined yet.
      # def CopyDiagFromSp(self, M: SpMatrix)

      # NOTE:
      # We cannot wrap this here since TpMatrix is not defined yet.
      # def CopyDiagFromTp(self, M: TpMatrix)

      def `Max` as max(self) -> float

      def `Max` as MaxIndex(self) -> (value: float, index: int)

      def `Min` as min(self) -> float

      def `Min` as MinIndex(self) -> (value: float, index: int)

      def Sum(self) -> float

      def SumLog(self) -> float

      def LogSumExp(self, prune: float = default) -> float

      # NOTE:
      # We cannot wrap this here since MatrixBase is not defined yet.
      # def AddRowSumMat(self, alpha: `float` as float, M: MatrixBase,
      #                  beta: `float` as float = default)

      # NOTE:
      # We cannot wrap this here since MatrixBase is not defined yet.
      # def AddColSumMat(self, alpha: `float` as float, M: MatrixBase,
      #                  beta: `float` as float = default)

      # NOTE:
      # We cannot wrap this here since MatrixBase is not defined yet.
      # def AddDiagMat2(self, alpha: `float` as float, M: MatrixBase,
      #                 trans: MatrixTransposeType = default,
      #                 beta: `float` as float = default)

      # NOTE:
      # We cannot wrap this here since MatrixBase is not defined yet.
      # def AddDiagMatMat(self, alpha: `float` as float,
      #                   M: MatrixBase, transM: MatrixTransposeType,
      #                   N: MatrixBase, transN: MatrixTransposeType,
      #                   beta: `float` as float = default)

      # TODO(Dogan): Wrap istream.
      # def Read(in: istream, binary: bool, add: bool = false);

      # TODO(Dogan): Wrap ostream.
      # def Write(in: ostream, binary: bool);

    # class `SubVector<float>` as SubVector(VectorBase):
    #   def __init__(self, t: VectorBase, offset: int, length: int)
    #
    #   @add__init__
    #   def `SubVector` as NewWithSubVector(self, s: SubVector)
    #
    #   # NOTE:
    #   # We cannot wrap this here since PackedMatrix is not defined yet.
    #   # @add__init__
    #   # def `SubVector` as CopyFromPackedMatrix(self, M: PackedMatrix)
    #
    #   # NOTE:
    #   # We cannot wrap this here since MatrixBase is not defined yet.
    #   # @add__init__
    #   # def `SubVector` as CopyFromMatrixRow(self, M: MatrixBase, row: int)
    #
    #   def Range(self, offset: int, length: int) -> SubVector
    #
    #   # def Attach(self, v: VectorBase, offset: int, length: int)


    class `Vector<float>` as Vector(VectorBase):
      @add__init__
      def `Vector` as NewWithSize(self, size: int,
                                  resize_type: MatrixResizeType = default)

      # NOTE:
      # Match fails since this signature matches both copy constructors.
      # No need to wrap this one since the copy constructor with VectorBase
      # argument covers both cases and does the same thing internally.
      # @add__init__
      # def `Vector` as NewWithVector(self, v: Vector)

      @add__init__
      def `Vector` as NewWithVector(self, v: VectorBase)

      def Swap(self, other: Vector)

      # TODO(Dogan): Wrap istream.
      # def Read(in: istream, binary: bool, add: bool = false);

      # NOTE:
      # We cannot wrap Range here since SubVector is wrapped elsewhere. We
      # implement the Range method in Python by constructing a SubVector.
      # def Range(self, offset: int, length: int) -> SubVector

      def `Resize` as resize_(self, length: int,
                              resize_type: MatrixResizeType = default)

      # NOTE:
      # Since CLIF combines setitem and delitem into a single wrapper,
      # we need to expose setitem in Vector as well. Otherwise setitem raises
      # NotImplementedError at runtime. This is probably a bug in CLIF.
      @sequential
      def `Set` as __setitem__(self, index: int, value: float)

      @sequential
      def `RemoveElement` as __delitem__(self, index: int)

    # TODO(Dogan): Wrap iostream and look into wrapping stream ops in Python.
    # def `operator<<` as Write(out: ostream, v: VectorBase) -> ostream
    # def `operator>>` as Write(in: istream, v: VectorBase) -> istream
    # def `operator>>` as Write(in: istream, v: Vector) -> istream

    # NOTE:
    # Explicit mention of compatible type `float` is needed for template
    # deduction. CLIF defaults to `double` for Python float.
    # These functions were renamed to avoid possible name conflicts.
    def `ApproxEqual` as ApproxEqualVector(a: VectorBase, b: VectorBase,
                                           tol: `float` as float = default) -> bool

    def `AssertEqual` as AssertEqualVector(a: VectorBase, b: VectorBase,
                                           tol: `float` as float = default)

    def VecVec(v1: VectorBase, v2: VectorBase) -> float

    # NOTE:
    # We cannot wrap this here since MatrixBase is not defined yet.
    # def VecMatVec(v1: VectorBase, M: MatrixBase, v2: VectorBase) -> float
