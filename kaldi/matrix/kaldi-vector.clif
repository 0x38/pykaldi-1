from "base/iostream-clifwrap.h" import *
from "matrix/matrix-common-clifwrap.h" import *

from "matrix/kaldi-vector.h":
  namespace `kaldi`:
    class `VectorBase<float>` as VectorBase:
      def `SetZero` as set_zero(self):
        """Set all elements to zero."""

      def `IsZero` as is_zero(self, cutoff: float = default) -> bool:
        """Return True if the max element is smaller than cutoff value.

        Args:
            cutoff(float): The cutoff value

        Returns:
            True if max(self) < cutoff
        """

      def `Set` as fill(self, f: float):
        """Assign the value f to every element in the vector.

        Args:
            f(float): The value to assign
        """

      def `SetRandn` as set_randn(self):
        """Set vector to random normally-distributed noise."""

      def `SetRandUniform` as set_randn_uniform(self):
        """Sets vector elements to numbers uniformly distributed on (0,1)."""

      def `RandCategorical` as rand_categorical(self) -> int:
        """This function returns a random index into this vector, chosen with
           probability proportional to the corresponding element. It requires the minimum
           value of the vector to be greater or equal to zero and the sum to
           be greather than zero.

        Raises:
            Error if min(self)<0 || sum(self)<=0
        """

      def `Dim` as __len__(self) -> int

      def `Dim` as size(self) -> int:
        """Returns the dimension of the vector."""

      def `Dim` as dim(self) -> int:
        """Returns the dimension of the vector."""

      def `SizeInBytes` as size_in_bytes(self) -> int:
        """Returns the size in memory of the vector, in bytes."""

      # NOTE:
      # It is probably a bad idea to expose the Data method in Python since its
      # return value is a pointer to the underlying data array which can easily
      # become dangling as C++ object lifetime is different from Python object
      # lifetime. Also, CLIF does not support C arrays (or raw pointers to C
      # arrays), hence we cannot automatically generate a wrapper for it. One
      # option is to add another method to the C++ API wrapping the data array
      # with a shared pointer. Another option is to write the wrapper manually.
      #
      # def Data(self) -> float

      def `operator()` as get(self, index: int) -> float:
        """Indexing operator.

        Args:
            index(int): Which element of the vector to access. Indexing starts from 0

        Returns:
            The value of the indexed element
        """

      def `Set` as set(self, index: int, value: float):
        """Assign value to index, v(index)=value.

        Args:
            index(int): Which element of the vector to access
            value(float): The value to be assigned.
        """

      # NOTE:
      # We wrap this in Python by constructing a new SubVector.
      # def Range(self, o: int, l: int) -> SubVector

      def `CopyFromVec` as copy_from_vec(self, v: VectorBase):
        """Copy data from another vector v of the same size.

        Args:
            v(VectorBase): The vector to copy from

        Raises:
            Error if v has different size than self
        """

      # NOTE:
      # We cannot wrap this here since PackedMatrix is not defined yet.
      # def CopyFromPacked(self, M: PackedMatrix)

      def `ApplyLog` as apply_log(self):
        """Apply natural log to all elements."""

      def `ApplyLogAndCopy` as apply_log_and_copy(self, v: VectorBase):
        """Apply natural log to vector v and copy the results to this one."""

      def `ApplyExp` as apply_exp(self):
        """Apply exponential to each value in vector."""

      def `ApplyAbs` as apply_abs(self):
        """Apply absolute value to each value in vector."""

      def `ApplyFloor` as apply_floor(self, floor: float) -> int:
        """Applies floor to all elements. Returns number of elements floored.
           If self(i)<floor then self(i)=floor.

        Args:
            floor(float): The floor value to check against.

        Returns:
            The number of elements changed.
        """

      def `ApplyCeiling` as apply_ceiling(self, ceiling: float) -> int:
        """Applies floor to all elements. Returns number of elements ceiled.
           If self(i)>ceiling then self(i)=ceiling.

        Args:
            ceiling(float): The ceiling value to check against

        Returns:
            The number of elements changed
        """

      def `ApplyFloor` as apply_floor_vector(self, floor: VectorBase) -> int:
        """Applies floor with respect to the elements of ``floor''.
           For example, for every element of this vector if
           v(i) < floor(i) then v(i)=floor(i).

        Args:
            floor(VectorBase): The vector to check against

        Returns:
            The number of elements changed
        """

      def `ApplySoftMax` as apply_softmax(self) -> float:
        """Apply the softmax operator to the vector and return
           normalizer (log sum of exponentials).
           x(i) = exp(x_i)/Sum(exp(x_i))

        Returns:
           log(Sum(exp(x_i)))
        """

      def `ApplyLogSoftMax` as apply_log_softmax(self) -> float:
        """Apply the softmax operator to the vector and return
           normalizer (log sum of exponentials).
           x(i) = exp(x_i) - log(Sum(exp(x_i))).

        Returns:
           -log(Sum(exp(x_i)))
        """

      def `Tanh` as tanh(self, src: VectorBase):
        """Sets each element of self to the tanh of the corresponding element of src.

        Args:
            src(VectorBase): The vector whose elements will be used
                             to calculate tanh and copy to self

        Raises:
            Error if src has different size than self
        """

      def `Sigmoid` as sigmoid(self, src: VectorBase):
        """Sets each element of self to the sigmoid of the corresponding element of src.

        Args:
            src(VectorBase): The vector whose elements will be used to
                             calculate sigmoid and copy to self.

        Raises:
            Error if src has different size than self
        """

      def `ApplyPow` as apply_pow(self, power: float):
        """Take all elements of vector to a power.

        Args:
            power(float): The power which we apply to all elements of self

        Raises:
            Error if you try to handle imaginary numbers
            (e.g. square root of a negative) or in case of overflow.
        """

      def `ApplyPowAbs` as apply_pow_abs(self, power: float, include_sign: bool = default):
        """Take the absolute value of all elements of a vector to a power.
           Include the sign of the input element if include_sign == true.
           For example, if self=(-3,2) then for power=2 and include_sign=true
           we would have self=(-9,4). If power is negative and the input
           value is zero, the output is set zero.

        Args:
            power(float): The power which we apply to all alements of self
            include_sign(bool): True if we include the sign of the input element

        Raises:
            Error if we have overflows or underflows.
        """

      def `Norm` as norm(self, p: float) -> float:
        """Compute the p-th norm of the vector.

        Args:
            p(float): Defines which norm order to use. It must be p>=0

        Returns:
            A float, the norm.

        Raises:
            Error if p<0 or we have overflows/underflows.
        """

      def `ApproxEqual` as approx_equal(self, other: VectorBase, tol: float = default) -> bool:
        """Returns true if the 2nd norm of the difference of
           this vector and other is less or equal than tol.

        Args:
            other(VectorBase): The vector to check against
            tol(float): The tolerance

        Returns:
            True if ||self-other||_p <=tol

        Raises:
            Error if size of other is different than size of self, or if tol<0.
        """

      def `InvertElements` as invert_elements(self):
        """Invert all elements. x(i) = 1/x(i).

        Raises:
            Error if at least one x(i) is 0
        """

      def `AddVec` as add_vec(self, alpha: float, v: VectorBase):
        """Vector addition. self = self + alpha * v.

        Args:
            alpha(float): a scaling constant
            v(VectorBase): a vector

        Raises:
            Error if the size of v is different than the size of self
        """

      def `AddVec2` as add_vec2(self, alpha: float, v: VectorBase):
        """Vector addition. self = self + alpha * v^2.

        Args:
            alpha(float): a scaling constant
            v(VectorBase): a vector

        Raises:
            Error if the size of v is different than the size of self
        """

      # NOTE:
      # We cannot wrap this here since MatrixBase is not defined yet.
      # def AddMatVec(self, alpha: `float` as float, M: MatrixBase,
      #               trans: MatrixTransposeType, v: VectorBase,
      #               beta: `float` as float)

      # NOTE:
      # We cannot wrap this here since MatrixBase is not defined yet.
      # def AddMatSvec(self, alpha: `float` as float, M: MatrixBase,
      #                trans: MatrixTransposeType, v: VectorBase,
      #                beta: `float` as float)

      # NOTE:
      # We cannot wrap this here since SpMatrix is not defined yet.
      # def AddSpVec(self, alpha: `float` as float, M: SpMatrix,
      #              v: VectorBase, beta: `float` as float)

      # NOTE:
      # We cannot wrap this here since TpMatrix is not defined yet.
      # def AddTpVec(self, alpha: `float` as float, M: TpMatrix,
      #              trans: MatrixTransposeType, v: VectorBase,
      #              beta: `float` as float)

      def `ReplaceValue` as replace_value(self, orig: float, changed: float):
        """Replace every every element with value orig with changed.
           If v(i)==orig then v(i)=changed, for all i.

        Args:
            orig(float): The value we want to change
            changed(float): The value we want to assign
        """

      def `MulElements` as mul_elements(self, v: VectorBase):
        """Multipy element-by-element by another vector.

        Args:
            v(VectorBase): a vector

        Raises:
            Error if the size of v is different than the size of self.
        """

      def `DivElements` as div_elements(self, v: VectorBase):
        """Divide element-by-element by a vector

        Args:
            v(VectorBase): a vector

        Raises:
            Error if the size of v is different than the size of self.
        """

      def `Add` as add(self, constant: float):
        """Add a constant to each element of a vector. self = self+constant.

        Args:
            constant(float): The constant which we will add to the vector.
        """

      def `AddVecVec` as add_vec_vec(self, alpha: float, v: VectorBase,
                    r: VectorBase, beta: float):
        """Elementwise addition of product of vectors to self.
           self = alpha*v*r + beta*self

        Args:
            alpha(float): a scaling constant
            v(VectorBase): a vector
            r(VectorBase): a vector
            beta(float): a scaling constant

        Raises:
            Error if dimensions do not match
        """

      def `AddVecDivVec` as add_vec_div_vec(self, alpha: float, v: VectorBase,
                       r: VectorBase, beta: float):
        """Elementwise addition of quotient of vectors to self.
           self = alpha*v./r + beta*self.

        Args:
            alpha(float): a scaling constant
            v(VectorBase): a vector
            r(VectorBase): a vector
            beta(float): a scaling constant

        Raises:
            Error if dimensions do not match
        """

      def `Scale` as scale(self, alpha: float):
        """Multiplies all elements by this constant. self=self*alpha.

        Args:
            alpha(float): A constant to scale the vector.
        """

      # NOTE:
      # We cannot wrap this here since TpMatrix is not defined yet.
      # def MulTp(self, M: TpMatrix, trans: MatrixTransposeType)

      # NOTE:
      # We cannot wrap this here since TpMatrix is not defined yet.
      # def Solve(self, M: TpMatrix, trans: MatrixTransposeType)

      # NOTE:
      # We cannot wrap this here since MatrixBase is not defined yet.
      # def CopyRowsFromMat(self, M: MatrixBase)

      # NOTE:
      # We cannot wrap this here since MatrixBase is not defined yet.
      # def CopyColsFromMat(self, M: MatrixBase)

      # NOTE:
      # We cannot wrap this here since MatrixBase is not defined yet.
      # def CopyRowFromMat(self, M: MatrixBase, row: int)

      # NOTE:
      # We cannot wrap this here since MatrixBase is not defined yet.
      # def CopyColFromMat(self, M: MatrixBase, col: int)

      # NOTE:
      # We cannot wrap this here since MatrixBase is not defined yet.
      # def CopyDiagFromMat(self, M: MatrixBase)

      # NOTE:
      # We cannot wrap this here since PackedMatrix is not defined yet.
      # def CopyDiagFromPacked(self, M: PackedMatrix)

      # NOTE:
      # We cannot wrap this here since SpMatrix is not defined yet.
      # def CopyDiagFromSp(self, M: SpMatrix)

      # NOTE:
      # We cannot wrap this here since TpMatrix is not defined yet.
      # def CopyDiagFromTp(self, M: TpMatrix)

      def `Max` as max(self) -> float:
        """Returns the maximum value of the vector."""

      def `Max` as max_index(self) -> (value: float, index: int):
        """Returns the maximum value of the vector, and the associated index."""

      def `Min` as min(self) -> float:
        """Returns the minimum value of the vector."""

      def `Min` as min_index(self) -> (value: float, index: int):
        """Returns the minimum value of the vector, and the associated index."""

      def `Sum` as sum(self) -> float:
        """Return the sum of the elements of the vector."""

      def `SumLog` as sum_log(self) -> float:
        """Returns sum of the logs of the elements.
           Will return NaN if any elements are negative.
        """

      def `LogSumExp` as log_sum_exp(self, prune: float = default) -> float:
        """Returns log(sum(exp())) without exp overflow.
           If prune > 0.0, ignores terms less than the max - prune.

        Args:
            prune(float): A pruning constant/

        Returns:
            The log(sum(exp(self))).
        """

      # NOTE:
      # We cannot wrap this here since MatrixBase is not defined yet.
      # def AddRowSumMat(self, alpha: `float` as float, M: MatrixBase,
      #                  beta: `float` as float = default)

      # NOTE:
      # We cannot wrap this here since MatrixBase is not defined yet.
      # def AddColSumMat(self, alpha: `float` as float, M: MatrixBase,
      #                  beta: `float` as float = default)

      # NOTE:
      # We cannot wrap this here since MatrixBase is not defined yet.
      # def AddDiagMat2(self, alpha: `float` as float, M: MatrixBase,
      #                 trans: MatrixTransposeType = default,
      #                 beta: `float` as float = default)

      # NOTE:
      # We cannot wrap this here since MatrixBase is not defined yet.
      # def AddDiagMatMat(self, alpha: `float` as float,
      #                   M: MatrixBase, transM: MatrixTransposeType,
      #                   N: MatrixBase, transN: MatrixTransposeType,
      #                   beta: `float` as float = default)

      def `Read` as read(self, is: istream, binary: bool, add: bool = default):
        """Reads from C++ stream.

        Args:
            is(istream): The input straem.
            binary(bool): If the stream is binary.
            add(bool): True if you want to add the stream to self.
        """


      def `Write` as write(self, os: ostream, binary: bool):
        """Writes to C++ stream.

        Args:
            os(ostream): The output straem.
            binary(bool): If the stream is binary.
        """

    # Note: SubVector is wrapped manually. See matrix-ext.cc
    #
    # class `SubVector<float>` as SubVector(VectorBase):
    #   def __init__(self, t: VectorBase, offset: int, length: int)
    #
    #   @add__init__
    #   def `SubVector` as NewWithSubVector(self, s: SubVector)
    #
    #   # NOTE:
    #   # We cannot wrap this here since PackedMatrix is not defined yet.
    #   # @add__init__
    #   # def `SubVector` as CopyFromPackedMatrix(self, M: PackedMatrix)
    #
    #   # NOTE:
    #   # We cannot wrap this here since MatrixBase is not defined yet.
    #   # @add__init__
    #   # def `SubVector` as CopyFromMatrixRow(self, M: MatrixBase, row: int)
    #
    #   def Range(self, offset: int, length: int) -> SubVector


    class `Vector<float>` as Vector(VectorBase):
      @add__init__
      def `Vector` as new_with_size(self, size: int,
                                  resize_type: MatrixResizeType = default):
        """Create a new vector of length size. If the size type is kSetZero,
           the new data will be zero. If the resize type is kUndefined,
           the new data will be undefined. Finally if the resize type is kCopyData,
           the new data will be the same as the old data in any shared positions,
           and zero elsewhere.

        Args:
            size(int): The number of elements in the vector.
            resize_type(MatrixResizeType): Determines the initial values of the vector.
        """

      # NOTE:
      # Match fails since this signature matches both copy constructors.
      # No need to wrap this one since the copy constructor with VectorBase
      # argument covers both cases and does the same thing internally.
      # @add__init__
      # def `Vector` as NewWithVector(self, v: Vector)

      @add__init__
      def `Vector` as new_with_vector(self, v: VectorBase):
        """Create vector and copy the elements of v.

        Args:
            v(VectorBase): The vector from which we will copy its elements.
        """

      def `Swap` as _swap(self, other: Vector):
        """Swaps the contents of self and other. Shallow swap.

        Args:
            other(VectorBase): The vector whose elements we want to swap with self.
        """

      def `Read` as read(self, is: istream, binary: bool, add: bool = default):
        """Reads from C++ stream.

        Args:
            is(istream): The input straem.
            binary(bool): If the stream is binary.
            add(bool): True if you want to add the stream to self.
        """

      # NOTE:
      # We cannot wrap Range here since SubVector is wrapped elsewhere. We
      # implement the Range method in Python by constructing a SubVector.
      # def Range(self, offset: int, length: int) -> SubVector

      def `Resize` as _resize(self, length: int, resize_type: MatrixResizeType = default):
        """Set vector size to length (length can be zero).
           The default resize type is kSetZero, in which case the new data
           will be zero. If the resize type is kUndefined, the new data
           will be undefined. Finally if the resize type is kCopyData,
           the new data will be the same as the old data in any shared positions,
           and zero elsewhere.

        Args:
            length(int): The new size of the vector
            resize_type(MatrixResizeType): Determines the initial values of the vector.
        """

      def `RemoveElement` as remove_element(self, index: int):
        """Remove one element and shifts later elements down, reducing the dimension by one.

        Args:
            index(int): Determines the position in the vector. Indexing starts from 0.
        """

    # NOTE:
    # Explicit mention of compatible type `float` is needed for template
    # deduction. CLIF defaults to `double` for Python float.
    # These functions were renamed to avoid possible name conflicts.
    def `ApproxEqual` as approx_equal_vector(
        a: VectorBase, b: VectorBase, tol: `float` as float = default) -> bool:
      """Computes the 2nd norm of the difference of vector a and vector b
         and returns True if it is less or equal than tol.

      Args:
          a(VectorBase): A vector
          b(VectorBase): A vector
          tol(float): The tolerance.

      Returns:
          True ||a-b||_p <= tol

      Raises:
          Error if size of a is different than size of b.
      """

    def `AssertEqual` as assert_equal_vector(a: VectorBase, b: VectorBase,
                                             tol: float = default):
      """Computes the 2nd norm of the difference of vector a and vector b and
         checks if it is less or equal than tol.
         If the condition is not satisfied it will raise an error.

      Args:
          a(VectorBase): A vector
          b(VectorBase): A vector
          tol(float): The tolerance.

      Raises:
          Error if ||a-b||_p > tol
      """

    def `VecVec` as vec_vec(v1: VectorBase, v2: VectorBase) -> float:
      """Returns dot product between v1 and v2.

      Args:
          v1(VectorBase): A vector
          v2(VectorBase): A vector

      Returns:
          The dot product of v1 and v2.

      Raises:
          Error if size of v1 is different than size of v2.
      """
    # NOTE:
    # We cannot wrap this here since MatrixBase is not defined yet.
    # def VecMatVec(v1: VectorBase, M: MatrixBase, v2: VectorBase) -> float

    class `VectorBase<double>` as DoubleVectorBase:
      def `SetZero` as set_zero(self):
        """Set all elements to zero."""

      def `IsZero` as is_zero(self, cutoff: float = default) -> bool:
        """Return True if the max element is smaller than cutoff value.

        Args:
            cutoff(float): The cutoff value

        Returns:
            True if max(self) < cutoff
        """

      def `Set` as fill(self, f: float):
        """Assign the value f to every element in the vector.

        Args:
            f(float): The value to assign
        """

      def `SetRandn` as set_randn(self):
        """Set vector to random normally-distributed noise."""

      def `SetRandUniform` as set_randn_uniform(self):
        """Sets vector elements to numbers uniformly distributed on (0,1)."""

      def `RandCategorical` as rand_categorical(self) -> int:
        """This function returns a random index into this vector, chosen
           with probability proportional to the corresponding element.
           It requires the minimum value of the vector to be greater or equal
           to zero and the sum to be greather than zero.

        Raises:
            Error if min(self)<0 || sum(self)<=0
        """

      def `Dim` as __len__(self) -> int:
        """Returns the dimension of the vector."""

      def `Dim` as size(self) -> int:
        """Returns the dimension of the vector."""

      def `Dim` as dim(self) -> int:
        """Returns the dimension of the vector."""

      def `SizeInBytes` as size_in_bytes(self) -> int:
        """Returns the size in memory of the vector, in bytes."""

      # NOTE:
      # It is probably a bad idea to expose the Data method in Python since its
      # return value is a pointer to the underlying data array which can easily
      # become dangling as C++ object lifetime is different from Python object
      # lifetime. Also, CLIF does not support C arrays (or raw pointers to C
      # arrays), hence we cannot automatically generate a wrapper for it. One
      # option is to add another method to the C++ API wrapping the data array
      # with a shared pointer. Another option is to write the wrapper manually.
      #
      # def Data(self) -> float

      def `operator()` as get(self, index: int) -> float:
        """Indexing operator.

        Args:
            index(int): Which element of the vector to access. Indexing starts from 0.

        Returns:
            The value of the indexed element
        """

      def `Set` as set(self, index: int, value: float):
        """Assign value to index, v(index)=value.

        Args:
            index(int): Which element of the vector to access.
            value(float): The value to be assigned.
        """

      # NOTE:
      # We wrap this in Python by constructing a new SubVector.
      # def Range(self, o: int, l: int) -> SubVector

      def `CopyFromVec` as copy_from_vec(self, v: DoubleVectorBase):
        """Copy data from another vector v of the same size.

        Args:
            v(VectorBase): The vector to copy from.

        Raises:
            Error if v has different size than self
        """

      # NOTE:
      # We cannot wrap this here since PackedMatrix is not defined yet.
      # def CopyFromPacked(self, M: PackedMatrix)

      def `ApplyLog` as apply_log(self):
        """Apply natural log to all elements."""

      def `ApplyLogAndCopy` as apply_log_and_copy(self, v: DoubleVectorBase):
        """Apply natural log to vector v and copy the results to this one."""

      def `ApplyExp` as apply_exp(self):
        """Apply exponential to each value in vector."""

      def `ApplyAbs` as apply_abs(self):
        """Apply absolute value to each value in vector."""

      def `ApplyFloor` as apply_floor(self, floor: float) -> int:
        """Applies floor to all elements. Returns number of elements floored.
           If self(i)<floor then self(i)=floor.

        Args:
            floor(float): The floor value to check against.

        Returns:
            The number of elements changed.
        """

      def `ApplyCeiling` as apply_ceiling(self, ceiling: float) -> int:
        """Applies floor to all elements. Returns number of elements ceiled.
           If self(i)>ceiling then self(i)=ceiling.

        Args:
            ceiling(float): The ceiling value to check against.

        Returns:
            The number of elements changed.
        """

      def `ApplyFloor` as apply_floor_vector(self, floor: DoubleVectorBase) -> int:
        """Applies floor with respect to the elements of ``floor''.
           For example, for every element of this vector
           if v(i) < floor(i) then v(i)=floor(i).

        Args:
            floor(VectorBase): The vector to check against.

        Returns:
            The number of elements changed.
        """

      def `ApplySoftMax` as apply_softmax(self) -> float:
        """Apply the softmax operator to the vector and
           return normalizer (log sum of exponentials).
           x(i) = exp(x_i)/Sum(exp(x_i))

        Returns:
           log(Sum(exp(x_i)))
        """

      def `ApplyLogSoftMax` as apply_log_softmax(self) -> float:
        """Apply the softmax operator to the vector and
           return normalizer (log sum of exponentials).
           x(i) = exp(x_i) - log(Sum(exp(x_i))).

        Returns:
           -log(Sum(exp(x_i)))
        """

      def `Tanh` as tanh(self, src: DoubleVectorBase):
        """Sets each element of self to the tanh of the corresponding element of src.

        Args:
            src(VectorBase): The vector whose elements will be used to calculate tanh
                             and copy to self.

        Raises:
            Error if src has different size than self
        """

      def `Sigmoid` as sigmoid(self, src: DoubleVectorBase):
        """Sets each element of self to the sigmoid of the corresponding element of src.

        Args:
            src(VectorBase): The vector whose elements will be used to calculate sigmoid
                             and copy to self.

        Raises:
            Error if src has different size than self
        """

      def `ApplyPow` as apply_pow(self, power: float):
        """Take all elements of vector to a power.

        Args:
            power(float): The power which we apply to all elements of self

        Raises:
            Error if you try to handle imaginary numbers
            (e.g. square root of a negative) or in case of overflow.
        """

      def `ApplyPowAbs` as apply_pow_abs(self, power: float, include_sign: bool = default):
        """Take the absolute value of all elements of a vector to a power.
           Include the sign of the input element if include_sign == true.
           For example, if self=(-3,2) then for power=2 and include_sign=true
           we would have self=(-9,4). If power is negative and the input value
           is zero, the output is set zero.

        Args:
            power(float): The power which we apply to all alements of self
            include_sign(bool): True if we include the sign of the input element.

        Raises:
            Error if we have overflows or underflows.
        """

      def `Norm` as norm(self, p: float) -> float:
        """Compute the p-th norm of the vector.

        Args:
            p(float): Defines which norm order to use. It must be p>=0.

        Returns:
            A float, the norm.

        Raises:
            Error if p<0 or we have overflows/underflows.
        """

      def `ApproxEqual` as approx_equal(self, other: DoubleVectorBase, tol: float = default) -> bool:
        """Returns true if the 2nd norm of the difference of this vector
           and other is less or equal than tol.

        Args:
            other(VectorBase): The vector to check against.
            tol(float): The tolerance.

        Returns:
            True if ||self-other||_p <=tol

        Raises:
            Error if size of other is different than size of self, or if tol<0.
        """

      def `InvertElements` as invert_elements(self):
        """Invert all elements. x(i) = 1/x(i).

        Raises:
            Error if at least one x(i) is 0.
        """

      def `AddVec` as add_vec(self, alpha: float, v: DoubleVectorBase):
        """Vector addition. self = self + alpha * v.

        Args:
            alpha(float): a scaling constant.
            v(VectorBase): a vector

        Raises:
            Error if the size of v is different than the size of self.
        """

      def `AddVec2` as add_vec2(self, alpha: float, v: DoubleVectorBase):
        """Vector addition. self = self + alpha * v^2.

        Args:
            alpha(float): a scaling constant.
            v(VectorBase): a vector

        Raises:
            Error if the size of v is different than the size of self.
        """

      # NOTE:
      # We cannot wrap this here since MatrixBase is not defined yet.
      # def AddMatVec(self, alpha: `double` as float, M: MatrixBase,
      #               trans: MatrixTransposeType, v: DoubleVectorBase,
      #               beta: `double` as float)

      # NOTE:
      # We cannot wrap this here since MatrixBase is not defined yet.
      # def AddMatSvec(self, alpha: `double` as float, M: MatrixBase,
      #                trans: MatrixTransposeType, v: DoubleVectorBase,
      #                beta: `double` as float)

      # NOTE:
      # We cannot wrap this here since SpMatrix is not defined yet.
      # def AddSpVec(self, alpha: `double` as float, M: SpMatrix,
      #              v: DoubleVectorBase, beta: `double` as float)

      # NOTE:
      # We cannot wrap this here since TpMatrix is not defined yet.
      # def AddTpVec(self, alpha: `double` as float, M: TpMatrix,
      #              trans: MatrixTransposeType, v: DoubleVectorBase,
      #              beta: `double` as float)

      def `ReplaceValue` as replace_value(self, orig: float, changed: float):
        """Replace every every element with value orig with changed.
           If v(i)==orig then v(i)=changed, for all i.

        Args:
            orig(float): The value we want to change.
            changed(float): The value we want to assign.
        """

      def `MulElements` as mul_elements(self, v: DoubleVectorBase):
        """Multipy element-by-element by another vector.

        Args:
            v(VectorBase): a vector

        Raises:
            Error if the size of v is different than the size of self.
        """

      def `DivElements` as div_elements(self, v: DoubleVectorBase):
        """Divide element-by-element by a vector

        Args:
            v(VectorBase): a vector

        Raises:
            Error if the size of v is different than the size of self.
        """

      def `Add` as add(self, constant: float):
        """Add a constant to each element of a vector. self = self+constant.

        Args:
            constant(float): The constant which we will add to the vector.
        """

      # FIXME (VM):
      # def `AddVecVec` as add_vec_vec(self, float, v: DoubleVectorBase, r: DoubleVectorBase, beta: float):
      #   """Elementwise addition of product of vectors to self.
      #      self = alpha*v*r + beta*self

      #   Args:
      #       alpha(float): a scaling constant
      #       v(VectorBase): a vector
      #       r(VectorBase): a vector
      #       beta(float): a scaling constant

      #   Raises:
      #       Error if dimensions do not match
      #   """

      def `AddVecDivVec` as add_vec_div_vec(self, alpha: float, v: DoubleVectorBase,
                       r: DoubleVectorBase, beta: float):
        """Elementwise addition of quotient of vectors to self.
           self = alpha*v./r + beta*self.

        Args:
            alpha(float): a scaling constant
            v(VectorBase): a vector
            r(VectorBase): a vector
            beta(float): a scaling constant

        Raises:
            Error if dimensions do not match
        """

      def `Scale` as scale(self, alpha: float):
        """Multiplies all elements by this constant. self=self*alpha.

        Args:
            alpha(float): A constant to scale the vector.
        """

      # NOTE:
      # We cannot wrap this here since TpMatrix is not defined yet.
      # def MulTp(self, M: TpMatrix, trans: MatrixTransposeType)

      # NOTE:
      # We cannot wrap this here since TpMatrix is not defined yet.
      # def Solve(self, M: TpMatrix, trans: MatrixTransposeType)

      # NOTE:
      # We cannot wrap this here since MatrixBase is not defined yet.
      # def CopyRowsFromMat(self, M: MatrixBase)

      # NOTE:
      # We cannot wrap this here since MatrixBase is not defined yet.
      # def CopyColsFromMat(self, M: MatrixBase)

      # NOTE:
      # We cannot wrap this here since MatrixBase is not defined yet.
      # def CopyRowFromMat(self, M: MatrixBase, row: int)

      # NOTE:
      # We cannot wrap this here since MatrixBase is not defined yet.
      # def CopyColFromMat(self, M: MatrixBase, col: int)

      # NOTE:
      # We cannot wrap this here since MatrixBase is not defined yet.
      # def CopyDiagFromMat(self, M: MatrixBase)

      # NOTE:
      # We cannot wrap this here since PackedMatrix is not defined yet.
      # def CopyDiagFromPacked(self, M: PackedMatrix)

      # NOTE:
      # We cannot wrap this here since SpMatrix is not defined yet.
      # def CopyDiagFromSp(self, M: SpMatrix)

      # NOTE:
      # We cannot wrap this here since TpMatrix is not defined yet.
      # def CopyDiagFromTp(self, M: TpMatrix)

      def `Max` as max(self) -> float:
        """Returns the maximum value of the vector."""

      def `Max` as max_index(self) -> (value: float, index: int):
        """Returns the maximum value of the vector, and the associated index."""

      def `Min` as min(self) -> float:
        """Returns the minimum value of the vector."""

      def `Min` as min_index(self) -> (value: float, index: int):
        """Returns the minimum value of the vector, and the associated index."""

      def `Sum` as sum(self) -> float:
        """Return the sum of the elements of the vector."""

      def `SumLog` as sum_log(self) -> float:
        """Returns sum of the logs of the elements."""

      def `LogSumExp` as log_sum_exp(self, prune: float = default) -> float:
        """Returns log(sum(exp())) without exp overflow.
           If prune > 0.0, ignores terms less than the max - prune.

        Args:
            prune(float): A pruning constant/

        Returns:
            The log(sum(exp(self))).
        """

      # NOTE:
      # We cannot wrap this here since MatrixBase is not defined yet.
      # def AddRowSumMat(self, alpha: `double` as float, M: MatrixBase,
      #                  beta: `double` as float = default)

      # NOTE:
      # We cannot wrap this here since MatrixBase is not defined yet.
      # def AddColSumMat(self, alpha: `double` as float, M: MatrixBase,
      #                  beta: `double` as float = default)

      # NOTE:
      # We cannot wrap this here since MatrixBase is not defined yet.
      # def AddDiagMat2(self, alpha: `double` as float, M: MatrixBase,
      #                 trans: MatrixTransposeType = default,
      #                 beta: `double` as float = default)

      # NOTE:
      # We cannot wrap this here since MatrixBase is not defined yet.
      # def AddDiagMatMat(self, alpha: `double` as float,
      #                   M: MatrixBase, transM: MatrixTransposeType,
      #                   N: MatrixBase, transN: MatrixTransposeType,
      #                   beta: `double` as float = default)

      def `Read` as read(self, is: istream, binary: bool, add: bool = default):
        """Reads from C++ stream.

        Args:
            is(istream): The input straem.
            binary(bool): If the stream is binary.
            add(bool): True if you want to add the stream to self.
        """

      def `Write` as write(self, os: ostream, binary: bool):
        """Writes to C++ stream.

        Args:
            os(ostream): The output straem.
            binary(bool): If the stream is binary.
        """

    class `Vector<double>` as DoubleVector(DoubleVectorBase):
      @add__init__
      def `Vector` as new_with_size(self, size: int,
                                  resize_type: MatrixResizeType = default):
        """Create a new vector of length size. If the size type is kSetZero,
           the new data will be zero. If the resize type is kUndefined,
           the new data will be undefined. Finally if the resize type is kCopyData,
           the new data will be the same as the old data in any shared positions,
           and zero elsewhere.

        Args:
            size(int): The number of elements in the vector.
            resize_type(MatrixResizeType): Determines the initial values of the vector.
        """

      # NOTE:
      # Match fails since this signature matches both copy constructors.
      # No need to wrap this one since the copy constructor with VectorBase
      # argument covers both cases and does the same thing internally.
      # @add__init__
      # def `Vector` as NewWithVector(self, v: DoubleVector)

      @add__init__
      def `Vector` as new_with_vector(self, v: DoubleVectorBase):
        """Create vector and copy the elements of v.

        Args:
            v(VectorBase): The vector from which we will copy its elements.
        """

      def `Swap` as swap(self, other: DoubleVector):
        """Swaps the contents of self and other. Shallow swap.

        Args:
            other(VectorBase): The vector whose elements we want to swap with self.
        """

      def `Read` as read(self, is: istream, binary: bool, add: bool = default):
        """Reads from C++ stream.

        Args:
            is(istream): The input straem.
            binary(bool): If the stream is binary.
            add(bool): True if you want to add the stream to self.
        """
      # NOTE:
      # We cannot wrap Range here since SubVector is wrapped elsewhere. We
      # implement the Range method in Python by constructing a SubVector.
      # def Range(self, offset: int, length: int) -> SubVector

      def `Resize` as _resize(self, length: int, resize_type: MatrixResizeType = default):
        """Set vector size to length (length can be zero).
           The default resize type is kSetZero, in which case the new data will
           be zero. If the resize type is kUndefined, the new data will be undefined.
           Finally if the resize type is kCopyData, the new data will be the same as
           the old data in any shared positions, and zero elsewhere.

        Args:
            length(int): The new size of the vector
            resize_type(MatrixResizeType): Determines the initial values of the vector.
        """

      def `RemoveElement` as remove_element(self, index: int):
        """Remove one element and shifts later elements down, reducing the dimension by one.

        Args:
            index(int): Determines the position in the vector. Indexing starts from 0.
        """

    # NOTE:
    # Explicit mention of compatible type `double` is needed for template
    # deduction. CLIF defaults to `double` for Python float.
    # These functions were renamed to avoid possible name conflicts.
    def `ApproxEqual` as approx_equal_double_vector(
        a: DoubleVectorBase, b: DoubleVectorBase,
        tol: `double` as float = default) -> bool:
      """Computes the 2nd norm of the difference of vector a and vector b
         and returns True if it is less or equal than tol.

      Args:
          a(VectorBase): A vector
          b(VectorBase): A vector
          tol(float): The tolerance.

      Returns:
          True if ||a-b||_p <= tol

      Raises:
          Error if size of a is different than size of b.
      """

    def `AssertEqual` as assert_equal_double_vector(
        a: DoubleVectorBase, b: DoubleVectorBase,
        tol: `double` as float = default):
      """Computes the 2nd norm of the difference of vector a and vector b
         and checks if it is less or equal than tol.
         If the condition is not satisfied it will raise an error.

      Args:
          a(VectorBase): A vector
          b(VectorBase): A vector
          tol(float): The tolerance.

      Raises:
          Error if ||a-b||_p > tol
      """

    def `VecVec` as double_vec_vec(v1: DoubleVectorBase,
                                 v2: DoubleVectorBase) -> float:
      """Returns dot product between v1 and v2.

      Args:
          v1(VectorBase): A vector
          v2(VectorBase): A vector

      Returns:
          The dot product of v1 and v2.

      Raises:
          Error if size of v1 is different than size of v2.
      """

    # NOTE:
    # We cannot wrap this here since MatrixBase is not defined yet.
    # def `VecMatVec` as DoubleVecMatVec(v1: DoubleVectorBase,
    #                                    M: DoubleMatrixBase,
    #                                    v2: DoubleVectorBase) -> float
