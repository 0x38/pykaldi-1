from "util/iostream-clifwrap.h" import *
from "matrix/matrix-common-clifwrap.h" import *
from "matrix/kaldi-vector-clifwrap.h" import *
from "matrix/kaldi-matrix-clifwrap.h" import *
from "matrix/matrix-ext.h" import *

from "matrix/packed-matrix.h":
  namespace `kaldi`:
    class `PackedMatrix<float>` as PackedMatrix:
#     FIXME(pavlos): Why this class has both num_rows and num_cols?
      """Base class for triangular and symmetric matrices.
 
      Args:
          _num_rows(int): The number of rows
          _num_cols(int): The number of columns
      """
      _num_rows: int = property(`NumRows`)
      _num_cols: int = property(`NumCols`)

      @add__init__
      def `PackedMatrix` as new_with_size(
          self, r:int, resize_type: MatrixResizeType = default):
        """Class initialization through size. Only the number or rows is important
           since this is a class for square matrices (triangular or symmetric)
           If the resize_type is kSetZero, the new data will be zero. If the resize type is kUndefined,
           the new data will be undefined. Finally if the resize type is kCopyData,
           the new data will be the same as the old data in any shared positions,
           and zero elsewhere. stride_type defines how data will be read from memory,
           we advise to let it in its default value.
 
        Args:
            r(int): The number of rows
            resize_type(MatrixResizeType): Default is kSetZero.
        """

      @add__init__
      def `PackedMatrix` as new_with_other(self, orig: PackedMatrix):
        """Initialize this PackedMatrix from another PackedMatrix.

        Args:
            orig(PackedMatrix): A matrix of class PackedMatrix
        """

      def `SetZero` as set_zero(self):
        """Set all elements to zero."""

      def `SetUnit` as set_unit(self):
        """Sets all elements to zero, and fill the diagonal with ones."""

      def `SetRandn` as set_randn(self):
        """Sets the elements to random values of a normal distribution."""

      def `Trace` as trace(self) -> float:
        """Return the trace of the matrix"""

      def `Resize` as resize(self, num_rows:int, resize_type: MatrixResizeType = default):
        """Resizes a matrix. If the resize_type is kSetZero,
           the new data will be zero. If the resize type is kUndefined,
           the new data will be undefined. Finally if the resize type is kCopyData,
           the new data will be the same as the old data in any shared positions,
           and zero elsewhere. stride_type defines how data will be read from memory,
           we advise to let it in its default value.

        Args:
            num_rows(int): The new number of rows
            resize_type(MatrixResizeType): Determines the initial values of the vector.
                                           Defualt is kSetZero
        """

      def `AddToDiag` as add_to_diag(self, r: float):
        """Add a constant r to the diagonal of the matrix.

        Args:
            r(float): A constant
        """

      def `ScaleDiag` as scale_diag(self, alpha: float):
        """Scale the diagonal of the matrix by alpha.

        Args:
            alpha(float): A scaling constant
        """

      def `SetDiag` as set_diag(self, alpha: float):
        """Set all the diagonal elements to alpha.

        Args:
            alpha(float): A constant
        """

      def `CopyFromPacked` as copy_from_packed(self, orig: PackedMatrix):
        """Copy data from a packed matrix.

        Args:
            orig(PackedMatrix): The packed matrix whose data we will copy
        
        Raises:
            Error in case of dimension mismatch
        """

      def `CopyFromVec` as copy_from_vec(self, orig: SubVector):
        """Interprets the vector as having the same layout as the packed matrix.
           Must have the same dimension, i.e. orig.size==(seld.num_rows*self.num_cols+1)/2;
          
        Args:
            orig(SubVector): A vector of class SubVector
        """

      def `NumRows` as __len__(self) -> int:
        """Return the number of rows."""

      def `NumRows` as num_rows(self) -> int:
        """Return the number of rows."""

      def `NumCols` as num_cols(self) -> int:
        """Return the number of columns."""

      def `SizeInBytes` as size_in_bytes(self) -> int:
        """Return the size of the matrix in memory, in bytes."""

      def `operator()` as get(self, r: int, c: int) -> float:
        """Indexing operator.

        Args:
            r(int): The index for row. Indexing starts from 0
            c(int): The index for column. Indexing starts from 0
 
        Returns:
            The indexed element

        Raises:
            Error if r > num_rows or c > num_cols
        """

      def `Max` as max(self) -> float:
        """Return the maximum elememnt of the matrix"""

      def `Min` as min(self) -> float:
        """Return the minimum  elememnt of the matrix"""

      def `Scale` as scale(self, c:float):
        """Scales the elements of the matrix."""

      def `Read` as read(self, is: istream, binary: bool, add: bool = default):
        """Reads from C++ stream.

        Args:
            is(istream): The input straem.
            binary(bool): If the stream is binary.
            add(bool): True if you want to add the stream to self.
        """

      def `Write` as write(self, os: ostream, binary: bool):
        """Writes to C++ stream.

        Args:
            os(ostream): The output straem
            binary(bool): If the stream is binary
        """

      def `Swap` as swap_with_packed(self, other: PackedMatrix):
        """Swaps the contents of self and other, where other is a
           a Packed Matrix. Shallow swap."""

      def `Swap` as swap_with_matrix(self, other: Matrix):
        """Swaps the contents of self and other, where other is a
           a Matrix. Shallow swap."""
